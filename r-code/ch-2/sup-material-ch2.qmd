---
title: "Main analysis ch2"
format:
  html:
    embed-resources: true
    self-contained-math: true
editor: source
cache: false
warning: false
message: false
---

```{r}
#| label: load-packages
library(dplyr)
library(ggplot2)
library(ggdist)
library(cowplot)
library(rstan)
library(posterior)
library(tidybayes)
library(bayesplot)
library(kableExtra)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

fig_path <- file.path(
  "..",
  "..",
  "figures",
  "ch-2"
)
tbl_path <- file.path(
  "..",
  "..",
  "tables",
  "ch-2"
)
```

```{r}
#| label: function-rTruncNorm
rTruncNorm <- function(n, mean, sd, lb = NULL, ub = NULL) {
  # Check if lower bound is supplied & 
  # calculate lower bound of uniform dist
  if (!is.null(lb)) {
    lb_unif <- pnorm((lb - mean) / sd)
  } else {
    lb_unif <- 0
  }
  if (!is.null(ub)) {
    ub_unif <- pnorm((ub - mean) / sd)
  } else {
    ub_unif <- 1
  }
  # Sample from uniform distribution
  unif_rv <- runif(n, lb_unif, ub_unif)
  # Probability integral transformation
  norm_rv <- (qnorm(unif_rv) * sd) + mean
  
  return(norm_rv)
}
```

```{r}
#| label: function-fn
fn <- function(x) {
  log(-log(1 - x))
}
```

```{r}
#| label: define-true-weibull-params
beta <- 1.1
eta <- 1
```

# Informative prior demonstration

Using the methods of keminskey we can encode a joint prior for the Weibull parameters by eliciting information about the CDF. This is much more intuitive than eliciting information about the parameters directly. The result is covariance in the joint posterior that encodes where we are uncertain. This is usefull in cases where the data are uninformative about some areas of the CDF but we do not want to impose a strong prior on the areas that the data are able to inform; for example right censoring masks longer lifetimes and so we can inject information through the joint prior to inform the upper tail of the distribution while still allowing the data to update the lower tail.

```{r}
#| label: fig-joint-priors
#| fig-cap: "..."
set.seed(567)
pp1s <- c(0.05, 0.35, 0.80)
pp2s <- c(0.20, 0.65, 0.95)
sds1 <- c(0.02, 0.04, 0.04)
sds2 <- c(0.04, 0.04, 0.02)
t1s <- lapply(
  pp1s,
  function(p) qweibull(p, beta, eta)
) %>%
  unlist()
t2s <- lapply(
  pp2s,
  function(p) qweibull(p, beta, eta)
) %>%
  unlist()

p_priors <- lapply(
  1:3,
  function(i) {
    n_draws <- 1000
    x_range <- c(0, 5)
    res <- 0.1
    # sample values of cdf
    samp_t1 <- rTruncNorm(
      n = n_draws,
      mean = pp1s[i], sd = sds1[i],
      lb = 0, ub = 1
    )
    samp_t2 <- rTruncNorm(
      n = n_draws,
      mean = pp2s[i], sd = sds2[i],
      lb = samp_t1, ub = 1
    )
    # calculate Weibull parameters
    beta_sample <- (fn(samp_t2) - fn(samp_t1)) / log(t2s[i] / t1s[i])
    eta_sample <- exp(log(t1s[i]) - (fn(samp_t1) / beta_sample))
    # plot joint dist and CDF
    cdf_grid <- seq(x_range[1], x_range[2], by = res)
    p_joint <- data.frame(
      beta = beta_sample,
      eta = eta_sample
    ) %>%
      ggplot() +
      geom_point(
        aes(x = beta_sample, y = eta_sample)
      ) +
      geom_point(
        x = beta,
        y = eta,
        col = "red"
      ) +
      xlim(0, 3) +
      ylim(0, 3) +
      xlab(expression(beta)) +
      ylab(expression(eta)) +
      theme_minimal()
    p_cdf <- data.frame(
      draw = rep(1:n_draws, each = length(cdf_grid)),
      t = rep(cdf_grid, n_draws)
    ) %>%
      mutate(
        cdf = pweibull(t, beta_sample[draw], eta_sample[draw])
      ) %>%
      ggplot() +
      stat_lineribbon(
        aes(x = t, y = cdf),
        .width = c(0.5, 0.9)
      ) +
      scale_fill_brewer() +
      geom_function(
        fun = pweibull,
        args = list(shape = beta, scale = eta),
        colour = "red"
      ) +
      theme_minimal() +
      theme(legend.position = "none")
      return(
        list(joint = p_joint, cdf = p_cdf)
      )
  }
)

p_joint_priors <- plot_grid(
  p_priors[[1]]$joint, p_priors[[2]]$joint, p_priors[[3]]$joint,
  p_priors[[1]]$cdf, p_priors[[2]]$cdf, p_priors[[3]]$cdf,
  nrow = 2,
  ncol = 3,
  labels = c(
    "(a)", "(b)", "(c)",
    "(d)", "(e)", "(f)"
  ),
  label_fontfamily = "Times",
  label_face = "plain"
)
p_joint_priors
```

```{r}
#| label: save-fig-joint-priors
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "joint-priors.pdf"),
  height = 6,
  width = 8
)
p_joint_priors
dev.off()
```

# Simulating data

```{r}
#| label: define-sim-params
N_units <- 10
t_start <- 5
t_window <- 1
t_end <- t_start + t_window
```


```{r}
#| label: function-SimData
SimData <- function(
  beta,
  eta,
  n_units,
  t_start,
  t_end
){
  # Calculate how many lifetimes to sample
  weibull_05_quant <- qweibull(0.05, shape = beta, scale = eta)
  n_lifetimes_per_unit <- ceiling(t_end / weibull_05_quant) * 2

  # Create simulation data frame
  small_sim <- data.frame(
      # Define units
      unit = factor(
        rep(1:n_units, each = n_lifetimes_per_unit),
        1:n_units
      ),
      # Sample for Weibull distribution
      lifetime = rweibull(
        n_units * n_lifetimes_per_unit,
        shape = beta,
        scale = eta
      )
    ) %>% 
    group_by(unit) %>%
    # Calculate the failure times and install times
    mutate(
      failure_time = cumsum(lifetime),
      install_time = lag(failure_time),
      lifetime_id = 1:n()
    ) %>%
    ungroup() %>%
    # Replace NAs created by lag() with t = 0
    replace(is.na(.), 0) %>%
    # Discard any lifetimes that didn't fail or within the observation period
    filter(
      between(install_time, t_start, t_end) |
      between(failure_time, t_start, t_end) |
      ((install_time < t_start) & (failure_time > t_end))
    ) %>%
    # Create right and interval censoring indicator variables
    mutate(
      int_censored = !between(install_time, t_start, t_end),
      right_censored = !between(failure_time, t_start, t_end),
      install_time_obs = ifelse(int_censored, t_start, install_time),
      failure_time_obs = ifelse(right_censored, t_end, failure_time)
    )

  return(small_sim)
}
```


```{r}
#| label: tbl-sim-data
#| tbl-cap: "..."
set.seed(549)
sim_df <- SimData(
  beta = beta,
  eta = eta,
  n_units = N_units,
  t_start = t_start,
  t_end = t_end
)

sim_df %>%
  kbl() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

```{r}
#| label: save-tbl-sim-data
#| echo: false
#| output: false
sim_df_latex <- sim_df %>%
  select(-c("lifetime_id", "int_censored", "right_censored"))
colnames(sim_df_latex) <- c(
  "Unit",
  "Lifetime",
  "True failure",
  "True install",
  "Observed install",
  "Observed failure"
)

sim_df_latex %>%
  mutate(across(-c("Unit"), ~ round(.x, 2))) %>%
  kbl(
    booktabs = T,
    format = "latex",
    caption = "The simulated CMMS data for ten units.",
    escape = FALSE,
    label = "sim-cmms-data"
  ) %>%
  kable_styling(latex_options = "striped") %>%
  save_kable(
    file = file.path(
      table_path,
      "sim_cmms_data.tex"
    ),
    keep_tex = TRUE
  )
```

```{r}
#| label: fig-sim-data
#| fig-cap: "..."
p_sim_data <- sim_df %>%
  mutate(i = 1:n()) %>%
  ggplot() +
  geom_segment(
    aes(x = install_time, y = i, xend = failure_time, yend = i),
    colour = "gray",
    linetype = 2
  ) +
  geom_segment(
    aes(x = install_time_obs, y = i, xend = failure_time_obs, yend = i),
    colour = "black",
    linetype = 1
  ) +
  geom_vline(xintercept = c(t_start, t_end), colour = "red", linetype = "dashed") +
  theme_minimal() +
  xlab("t") +
  ylab("") +
  theme(
    axis.text.y=element_blank(), 
    axis.ticks.y=element_blank()
  )

p_sim_data
```

```{r}
#| label: save-fig-sim-data
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "sim-data.pdf"),
  height = 6,
  width = 6
)
p_sim_data
dev.off()
```

```{r}
#| label: prep-stan-data
sim_df_obs <- sim_df %>%
  filter(!(right_censored | int_censored))
sim_df_rc <- sim_df %>%
  filter(right_censored & !int_censored)
sim_df_lt <- sim_df %>%
  filter(!right_censored & int_censored)
sim_df_lt_rc <- sim_df %>%
  filter(right_censored & int_censored)

stan_data_full <- list(
  N_obs = nrow(sim_df_obs),
  N_rc = nrow(sim_df_rc),
  N_lt = nrow(sim_df_lt),
  N_lt_rc = nrow(sim_df_lt_rc),
  y_obs = sim_df_obs$failure_time - sim_df_obs$install_time,
  y_rc = sim_df_rc$failure_time_obs - sim_df_rc$install_time,
  y_lt = sim_df_lt$failure_time - sim_df_lt$install_time,
  t_lt = sim_df_lt$install_time_obs - sim_df_lt$install_time,
  y_lt_rc = sim_df_lt_rc$failure_time_obs - sim_df_lt_rc$install_time,
  t_lt_rc = sim_df_lt_rc$install_time_obs - sim_df_lt_rc$install_time
)

stan_data_no_lt <- list(
  N_obs = nrow(sim_df_obs),
  N_rc = nrow(sim_df_rc),
  y_obs = sim_df_obs$failure_time - sim_df_obs$install_time,
  y_rc = sim_df_rc$failure_time_obs - sim_df_rc$install_time
)

stan_data_unkown_lt <- list(
  N_obs = nrow(sim_df_obs),
  N_rc = nrow(sim_df_rc),
  N_lt = nrow(sim_df_lt),
  N_lt_rc = nrow(sim_df_lt_rc),
  y_obs = sim_df_obs$failure_time - sim_df_obs$install_time,
  y_rc = sim_df_rc$failure_time_obs - sim_df_rc$install_time_obs,
  y_lt = sim_df_lt$failure_time_obs - sim_df_lt$install_time_obs,
  y_lt_rc = sim_df_lt_rc$failure_time_obs - sim_df_lt_rc$install_time_obs,
  t_start = t_start
)
```

## Stan models (weakly informative)

::: panel-tabset
### Known truncation times

```{r}
#| label: known-trunc-stan-model
stan_model_lt_r_imputed <- stan_model(
  model_code = "
data {
int N_obs;
int N_rc;
int N_lt;
int N_lt_rc;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
vector<lower=0>[N_lt] y_lt;
vector<lower=0>[N_lt] t_lt;
vector<lower=0>[N_lt_rc] y_lt_rc;
vector<lower=0>[N_lt_rc] t_lt_rc;
}
parameters {
real<lower = 0> beta;
real<lower = 0> eta;
vector<lower = y_rc>[N_rc] y_rc_hat;
vector<lower = y_lt_rc>[N_lt_rc] y_lt_rc_hat;
}
model{
// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}
// left truncated and right censored lifetimes
for (j in 1:N_lt_rc) {
  y_lt_rc_hat[j] ~ weibull(beta, eta) T[t_lt_rc[j], ]; 
}

// Prior model
eta ~ normal(1, 1);
beta ~ normal(1.1, 1);
}

"
)
```

### No truncated samples
```{r}
#| label: discarded-trunc-stan-model
stan_model_no_lt <- stan_model(
  model_code = "
data {
int N_obs;
int N_rc;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
}
parameters {
real<lower = 0> beta;
real<lower = 0> eta;
}
model{
// Data model
// fully observed lifetimes
target += weibull_lpdf(y_obs|beta, eta);
// right censored lifetimes
target += weibull_lccdf(y_rc|beta, eta);

// Prior model
eta ~ normal(1, 1);
beta ~ normal(1.1, 1);
}

"
)
```

### Impute truncation times
```{r}
#| label: imputed-trunc-stan-model
stan_model_unknown_lt_rc <- stan_model(
  model_code = "
data {
int N_obs;                             # N fully observed lives
int N_rc;                              # N right censored only lives
int N_lt;                              # N left truncated only lives
int N_lt_rc;                           # N right cens and left trunc lives
array[N_obs] real<lower=0> y_obs;      # Fully observed lifetimes
array[N_rc] real<lower=0> y_rc;        # Right censored lifetimes
array[N_lt] real<lower=0> y_lt;        # Left trunc lifetimes
array[N_lt_rc] real<lower=0> y_lt_rc;  # right cens and left trunc lifetimes
real<lower=0> t_start;                 # start of the observation window
}
transformed data{
array[N_lt] real<lower=0> y_lt_upper;  # The upper bound of the left trunc lives

for (m in 1:N_lt){
  y_lt_upper[m] = y_lt[m] + t_start;   # Upper bound = lower bound + start of observation
}

}
parameters {
real<lower= 0> beta;     # weibull shape
real<lower= 0> eta;      # weibull scale
array[N_rc] real<lower=y_rc> y_rc_hat;   # imputed right censored values
array[N_lt] real<lower=y_lt, upper=y_lt_upper> y_lt_hat;  # imputed left trunc values
array[N_lt_rc] real<lower=y_lt_rc> y_lt_rc_hat;   # imputed left trunc and right cens values
array[N_lt_rc] real<lower=0, upper=1> t_lt_rc_st; # imputed left truncation times for left trunc and right cens values (standardised)
}
transformed parameters{
array[N_lt] real t_lt;  # imputed left trunc times for left trunc values
array[N_lt_rc] real<lower=0, upper=t_start> t_lt_rc_upper;
array[N_lt_rc] real<lower=0, upper=t_lt_rc_upper> t_lt_rc;  # imputed left trunc times for left trunc and right cens values

for (i in 1:N_lt) {
  t_lt[i] = y_lt_hat[i] - y_lt[i];
}

for (k in 1:N_lt_rc){
  if ((y_lt_rc_hat[k] - y_lt_rc[k]) < t_start)
    t_lt_rc_upper[k] = y_lt_rc_hat[k] - y_lt_rc[k];
  else
    t_lt_rc_upper[k] = t_start;

  t_lt_rc[k] = t_lt_rc_st[k] * t_lt_rc_upper[k];
}
}
model{
// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt_hat[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}
// left truncated and right censored lifetimes
for (j in 1:N_lt_rc) {
  y_lt_rc_hat[j] ~ weibull(beta, eta) T[t_lt_rc[j], ]; 
}

// Prior model
eta ~ normal(1, 1);
beta ~ normal(1.1, 1);
t_lt_rc_st ~ uniform(0, 1);
}

"
)
```
:::

### Sampling

::: panel-tabset
#### Known truncation times
```{r}
#| label: fit-lt-known-model
stan_fit_lt_r_imputed <- sampling(
  stan_model_lt_r_imputed,
  stan_data_full,
  chains = 4,
  iter = 1000,
  warmup = 500
)
```

#### No truncated samples
```{r}
#| label: fit-lt-discarded-model
stan_fit_no_lt <- sampling(
  stan_model_no_lt,
  stan_data_no_lt,
  chains = 4,
  iter = 1000,
  warmup = 500
)
```

#### Impute truncation times
```{r}
#| label: fit-lt-imputed-model
stan_fit_unknown_lt_rc <- sampling(
  stan_model_unknown_lt_rc,
  stan_data_unkown_lt,
  chains = 4,
  iter = 1000,
  warmup = 500
)
```
:::

```{r}
#| label: function-PlotPostCDF
PlotPostCDF <- function(stan_fit, x_range = c(0, 5), res = 0.05) {
  grid <- seq(x_range[1], x_range[2], 0.01)
  p_cdf <- stan_fit %>%
    as_draws_df() %>%
    select(beta, eta) %>%
    split(., seq(nrow(.))) %>%
    lapply(
      function(draw) {
        df_CDF <- data.frame(
          q = grid,
          p = pweibull(grid, draw$beta, draw$eta)
        )
        return(df_CDF)
      }
    ) %>%
    bind_rows() %>%
    ggplot() +
    stat_lineribbon(
      aes(x = q, y = p),
      .width = c(0.5, 0.9)
    ) +
    scale_fill_brewer() +
    geom_function(
      fun = pweibull,
      args = list(shape = beta, scale = eta),
      colour = "red"
    ) +
    xlab("t") +
    ylab("cdf") +
    theme_minimal() +
    theme(legend.position = "none")
    return(p_cdf)
}
```

```{r}
#| label: fig-join-posts
#| fig-cap: "..."
p_full <- stan_fit_lt_r_imputed %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5) +
  xlab(expression(beta)) +
  ylab(expression(eta)) +
  theme_minimal()
p_no_lt <- stan_fit_no_lt %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5) +
  xlab(expression(beta)) +
  ylab(expression(eta)) +
  theme_minimal()
p_imp_lt <- stan_fit_unknown_lt_rc %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5) +
  xlab(expression(beta)) +
  ylab(expression(eta)) +
  theme_minimal()

p_cdf_full <- PlotPostCDF(stan_fit_lt_r_imputed)
p_cdf_no_lt <- PlotPostCDF(stan_fit_no_lt)
p_cdf_imp_lt <- PlotPostCDF(stan_fit_unknown_lt_rc)

p_joint_posts <- plot_grid(
  p_full, p_no_lt, p_imp_lt,
  p_cdf_full, p_cdf_no_lt, p_cdf_imp_lt,
  nrow = 2,
  ncol = 3,
  labels = c(
    "(a)", "(b)", "(c)",
    "(d)", "(e)", "(f)"
  ),
  label_fontfamily = "Times",
  label_face = "plain"
)
p_joint_posts
```

```{r}
#| label: save-fig-join-posts
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "joint-posts.pdf"),
  height = 5,
  width = 10
)
p_joint_posts
dev.off()
```

## Stan models (informative)

::: panel-tabset
### Known truncation times

```{r}
#| label: known-trunc-stan-model-inf
stan_model_lt_r_imputed_inf <- stan_model(
  model_code = "
functions {
// function to simplify the calculation of eta and beta
real fn(real tCDF) {
  return log(-log1m(tCDF));
}
}
data {
int N_obs;
int N_rc;
int N_lt;
int N_lt_rc;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
vector<lower=0>[N_lt] y_lt;
vector<lower=0>[N_lt] t_lt;
vector<lower=0>[N_lt_rc] y_lt_rc;
vector<lower=0>[N_lt_rc] t_lt_rc;
// Define the prior
real t_1;
real t_2;
real t1_mean;
real t1_var;
real t2_mean;
real t2_var;
}
parameters {
real<lower = 0, upper = 1> t1CDF;
real<lower = t1CDF, upper = 1> t2CDF;
vector<lower = y_rc>[N_rc] y_rc_hat;
vector<lower = y_lt_rc>[N_lt_rc] y_lt_rc_hat;
}
transformed parameters {
real<lower = 0> beta;
real<lower = 0> eta;

// calculate Weibull paramaters based on the
// draws from the CDF at t1 and t2.
beta = (fn(t2CDF) - fn(t1CDF)) / log(t_2 / t_1);
eta = exp(log(t_1) - (fn(t1CDF) / beta));
}
model{
// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}
// left truncated and right censored lifetimes
for (j in 1:N_lt_rc) {
  y_lt_rc_hat[j] ~ weibull(beta, eta) T[t_lt_rc[j], ]; 
}

// Prior model
t1CDF ~ normal(t1_mean, t1_var);
t2CDF ~ normal(t2_mean, t2_var);
}

"
)
```

### No truncated samples
```{r}
#| label: discarded-trunc-stan-model-inf
stan_model_no_lt_inf <- stan_model(
  model_code = "
functions {
// function to simplify the calculation of eta and beta
real fn(real tCDF) {
  return log(-log1m(tCDF));
}
}
data {
int N_obs;
int N_rc;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
// Define the prior
real t_1;
real t_2;
real t1_mean;
real t1_var;
real t2_mean;
real t2_var;
}
parameters {
real<lower = 0, upper = 1> t1CDF;
real<lower = t1CDF, upper = 1> t2CDF;
}
transformed parameters {
real<lower = 0> beta;
real<lower = 0> eta;

// calculate Weibull paramaters based on the
// draws from the CDF at t1 and t2.
beta = (fn(t2CDF) - fn(t1CDF)) / log(t_2 / t_1);
eta = exp(log(t_1) - (fn(t1CDF) / beta));
}
model{
// Data model
// fully observed lifetimes
target += weibull_lpdf(y_obs|beta, eta);
// right censored lifetimes
target += weibull_lccdf(y_rc|beta, eta);

// Prior model
t1CDF ~ normal(t1_mean, t1_var);
t2CDF ~ normal(t2_mean, t2_var);
}

"
)
```

### Impute truncation times
```{r}
#| label: imputed-trunc-stan-model-inf
stan_model_unknown_lt_rc_inf <- stan_model(
  model_code = "
functions {
// function to simplify the calculation of eta and beta
real fn(real tCDF) {
  return log(-log1m(tCDF));
}
}
data {
int N_obs;                             # N fully observed lives
int N_rc;                              # N right censored only lives
int N_lt;                              # N left truncated only lives
int N_lt_rc;                           # N right cens and left trunc lives
array[N_obs] real<lower=0> y_obs;      # Fully observed lifetimes
array[N_rc] real<lower=0> y_rc;        # Right censored lifetimes
array[N_lt] real<lower=0> y_lt;        # Left trunc lifetimes
array[N_lt_rc] real<lower=0> y_lt_rc;  # right cens and left trunc lifetimes
real<lower=0> t_start;                 # start of the observation window
// Define the prior
real t_1;
real t_2;
real t1_mean;
real t1_var;
real t2_mean;
real t2_var;
}
transformed data{
array[N_lt] real<lower=0> y_lt_upper;  # The upper bound of the left trunc lives

for (m in 1:N_lt){
  y_lt_upper[m] = y_lt[m] + t_start;   # Upper bound = lower bound + start of observation
}

}
parameters {
real<lower = 0, upper = 1> t1CDF;
real<lower = t1CDF, upper = 1> t2CDF;
array[N_rc] real<lower=y_rc> y_rc_hat;   # imputed right censored values
array[N_lt] real<lower=y_lt, upper=y_lt_upper> y_lt_hat;  # imputed left trunc values
array[N_lt_rc] real<lower=y_lt_rc> y_lt_rc_hat;   # imputed left trunc and right cens values
array[N_lt_rc] real<lower=0, upper=1> t_lt_rc_st; # imputed left truncation times for left trunc and right cens values (standardised)
}
transformed parameters{
real<lower = 0> beta;
real<lower = 0> eta;
array[N_lt] real t_lt;  # imputed left trunc times for left trunc values
array[N_lt_rc] real<lower=0, upper=t_start> t_lt_rc_upper;
array[N_lt_rc] real<lower=0, upper=t_lt_rc_upper> t_lt_rc;  # imputed left trunc times for left trunc and right cens values

// calculate Weibull paramaters based on the
// draws from the CDF at t1 and t2.
beta = (fn(t2CDF) - fn(t1CDF)) / log(t_2 / t_1);
eta = exp(log(t_1) - (fn(t1CDF) / beta));

for (i in 1:N_lt) {
  t_lt[i] = y_lt_hat[i] - y_lt[i];
}

for (k in 1:N_lt_rc){
  if ((y_lt_rc_hat[k] - y_lt_rc[k]) < t_start)
    t_lt_rc_upper[k] = y_lt_rc_hat[k] - y_lt_rc[k];
  else
    t_lt_rc_upper[k] = t_start;

  t_lt_rc[k] = t_lt_rc_st[k] * t_lt_rc_upper[k];
}
}
model{
// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt_hat[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}
// left truncated and right censored lifetimes
for (j in 1:N_lt_rc) {
  y_lt_rc_hat[j] ~ weibull(beta, eta) T[t_lt_rc[j], ]; 
}

// Prior model
t1CDF ~ normal(t1_mean, t1_var);
t2CDF ~ normal(t2_mean, t2_var);
t_lt_rc_st ~ uniform(0, 1);
}

"
)
```
:::

### Sampling

::: panel-tabset
#### Known truncation times
```{r}
#| label: fit-lt-known-model-inf
stan_fit_lt_r_imputed_inf <- sampling(
  stan_model_lt_r_imputed_inf,
  c(
    stan_data_full,
    t_1 = qweibull(0.8, beta, eta),
    t_2 = qweibull(0.95, beta, eta),
    t1_mean = 0.8,
    t1_var = 0.1,
    t2_mean = 0.95,
    t2_var = 0.05
  ),
  chains = 4,
  cores = 4,
  iter = 1000,
  warmup = 500
)
```

#### No truncated samples
```{r}
#| label: fit-lt-discarded-model-inf
stan_fit_no_lt_inf <- sampling(
  stan_model_no_lt_inf,
  c(
    stan_data_no_lt,
    t_1 = qweibull(0.8, beta, eta),
    t_2 = qweibull(0.95, beta, eta),
    t1_mean = 0.8,
    t1_var = 0.1,
    t2_mean = 0.95,
    t2_var = 0.05
  ),
  chains = 4,
  cores = 4,
  iter = 1000,
  warmup = 500
)
```

#### Impute truncation times
```{r}
#| label: fit-lt-imputed-model-inf
stan_fit_unknown_lt_rc_inf <- sampling(
  stan_model_unknown_lt_rc_inf,
  c(
    stan_data_unkown_lt,
    t_1 = qweibull(0.8, beta, eta),
    t_2 = qweibull(0.95, beta, eta),
    t1_mean = 0.8,
    t1_var = 0.1,
    t2_mean = 0.95,
    t2_var = 0.05
  ),
  chains = 4,
  cores = 4,
  iter = 1000,
  warmup = 500
)
```
:::

```{r}
#| label: fig-join-posts-inf
#| fig-cap: "..."
p_full_inf <- stan_fit_lt_r_imputed_inf %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5) +
  xlab(expression(beta)) +
  ylab(expression(eta)) +
  theme_minimal()
p_no_lt_inf <- stan_fit_no_lt_inf  %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5) +
  xlab(expression(beta)) +
  ylab(expression(eta)) +
  theme_minimal()
p_imp_lt_inf <- stan_fit_unknown_lt_rc_inf %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5) +
  xlab(expression(beta)) +
  ylab(expression(eta)) +
  theme_minimal()

p_cdf_full_inf <- PlotPostCDF(stan_fit_lt_r_imputed_inf)
p_cdf_no_lt_inf <- PlotPostCDF(stan_fit_no_lt_inf)
p_cdf_imp_lt_inf <- PlotPostCDF(stan_fit_unknown_lt_rc_inf)

p_joint_posts_inf <- plot_grid(
  p_full_inf, p_no_lt_inf, p_imp_lt_inf,
  p_cdf_full_inf, p_cdf_no_lt_inf, p_cdf_imp_lt_inf,
  nrow = 2,
  ncol = 3,
  labels = c(
    "(a)", "(b)", "(c)",
    "(d)", "(e)", "(f)"
  ),
  label_fontfamily = "Times",
  label_face = "plain"
)
p_joint_posts_inf
```

```{r}
#| label: save-fig-join-posts-inf
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "joint-posts-inf.pdf"),
  height = 5,
  width = 10
)
p_joint_posts_inf 
dev.off()
```

```{r}
#| label:fig-prior-post-comparison
#| fig-cap: "..."
p1 <- stan_fit_lt_r_imputed_inf %>%
  as_draws_rvars() %>%
  gather_rvars(t1CDF, t2CDF) %>%
  mutate(
    prior = c(
      rvar(rnorm(500000, 0.80, 0.1)),
      rvar(rnorm(500000, 0.95, 0.05))
    )
  ) %>%
  ggplot() +
  stat_halfeye(aes(xdist = .value, y = .variable)) +
  stat_slab(aes(xdist = prior, y = .variable), fill = NA, color = "#e41a1c") +
  scale_y_discrete(
    labels = c(
      expression(t[1]),
      expression(t[2])
    )
  ) +
  ylab("") +
  xlab(expression(F(t[i]))) +
  xlim(0, 1) +
  theme_minimal()
p2 <- stan_fit_no_lt_inf %>%
  as_draws_rvars() %>%
  gather_rvars(t1CDF, t2CDF) %>%
  mutate(
    prior = c(
      rvar(rnorm(500000, 0.80, 0.1)),
      rvar(rnorm(500000, 0.95, 0.05))
    )
  ) %>%
  ggplot() +
  stat_halfeye(aes(xdist = .value, y = .variable)) +
  stat_slab(aes(xdist = prior, y = .variable), fill = NA, color = "#e41a1c") +
  scale_y_discrete(
    labels = c(
      expression(t[1]),
      expression(t[2])
    )
  ) +
  ylab("") +
  xlab(expression(F(t[i]))) +
  xlim(0, 1) +
  theme_minimal()
p3 <- stan_fit_unknown_lt_rc_inf %>%
  as_draws_rvars() %>%
  gather_rvars(t1CDF, t2CDF) %>%
  mutate(
    prior = c(
      rvar(rnorm(500000, 0.80, 0.1)),
      rvar(rnorm(500000, 0.95, 0.05))
    )
  ) %>%
  ggplot() +
  stat_halfeye(aes(xdist = .value, y = .variable)) +
  stat_slab(aes(xdist = prior, y = .variable), fill = NA, color = "#e41a1c") +
  scale_y_discrete(
    labels = c(
      expression(t[1]),
      expression(t[2])
    )
  ) +
  ylab("") +
  xlab(expression(F(t[i]))) +
  xlim(0, 1) +
  theme_minimal()

plot_grid(
  p1, p2, p3,
  nrow = 1, ncol = 3,
  labels = c(
    "(a)", "(b)", "(c)"
  ),
  label_fontfamily = "Times",
  label_face = "plain"
)
```

```{r}
#| label:save-fig-prior-post-comparison
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "prior-post-comp.pdf"),
  height = 5,
  width = 10
)
plot_grid(
  p1, p2, p3,
  nrow = 1, ncol = 3,
  labels = c(
    "(a)", "(b)", "(c)"
  ),
  label_fontfamily = "Times",
  label_face = "plain"
)
dev.off()
```

# Strong likelihood

```{r}
#| label: simulate-large-dataset
set.seed(545)

sim_large_df <- SimData(
  beta = beta,
  eta = eta,
  n_units = 500,#N_units_large,
  t_start = 14.5,#t_start,
  t_end = 14.5 + 0.96#t_end
)

head(sim_large_df)
```

```{r}
sim_large_df_obs <- sim_large_df %>%
  filter(!(right_censored | int_censored))
sim_large_df_rc <- sim_large_df %>%
  filter(right_censored & !int_censored)
sim_large_df_lt <- sim_large_df %>%
  filter(!right_censored & int_censored)
sim_large_df_lt_rc <- sim_large_df %>%
  filter(right_censored & int_censored)

stan_data_full_large <- list(
  N_obs = nrow(sim_large_df_obs),
  N_rc = nrow(sim_large_df_rc),
  N_lt = nrow(sim_large_df_lt),
  N_lt_rc = nrow(sim_large_df_lt_rc),
  y_obs = sim_large_df_obs$failure_time - sim_large_df_obs$install_time,
  y_rc = sim_large_df_rc$failure_time_obs - sim_large_df_rc$install_time,
  y_lt = sim_large_df_lt$failure_time - sim_large_df_lt$install_time,
  t_lt = sim_large_df_lt$install_time_obs - sim_large_df_lt$install_time,
  y_lt_rc = sim_large_df_lt_rc$failure_time_obs - sim_large_df_lt_rc$install_time,
  t_lt_rc = sim_large_df_lt_rc$install_time_obs - sim_large_df_lt_rc$install_time
)

stan_data_no_lt_large <- list(
  N_obs = nrow(sim_large_df_obs),
  N_rc = nrow(sim_large_df_rc),
  y_obs = sim_large_df_obs$failure_time - sim_large_df_obs$install_time,
  y_rc = sim_large_df_rc$failure_time_obs - sim_large_df_rc$install_time
)

stan_data_unkown_lt_large <- list(
  N_obs = nrow(sim_large_df_obs),
  N_rc = nrow(sim_large_df_rc),
  N_lt = nrow(sim_large_df_lt),
  N_lt_rc = nrow(sim_large_df_lt_rc),
  y_obs = sim_large_df_obs$failure_time - sim_large_df_obs$install_time,
  y_rc = sim_large_df_rc$failure_time_obs - sim_large_df_rc$install_time,
  y_lt = sim_large_df_lt$failure_time - sim_large_df_lt$install_time_obs,
  y_lt_rc = sim_large_df_lt_rc$failure_time_obs - sim_large_df_lt_rc$install_time_obs,
  t_start = 14.5#t_start
)
```

## Week prior
::: panel-tabset
#### Known truncation times
```{r}
#| label: fit-full-model
stan_fit_lt_r_imputed_large <- sampling(
  stan_model_lt_r_imputed,
  stan_data_full_large,
  chains = 4,
  iter = 1000,
  warmup = 500
)
```

#### No truncated samples
```{r}
#| label: fit-no-lt-model
stan_fit_no_lt_large <- sampling(
  stan_model_no_lt,
  stan_data_no_lt_large,
  chains = 4,
  iter = 1000,
  warmup = 500
)
```

#### Impute truncation times
```{r}
#| label: fit-imp-lt-model
stan_fit_unknown_lt_rc_large <- sampling(
  stan_model_unknown_lt_rc,
  stan_data_unkown_lt_large,
  chains = 4,
  iter = 1000,
  warmup = 500,
  control = list(max_treedepth = 13)
)
```
:::

```{r}
#| label: fig-join-post-and-cdf
p_full_large <- stan_fit_lt_r_imputed_large %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5)
p_no_lt_large <- stan_fit_no_lt_large  %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5)
p_imp_lt_large <- stan_fit_unknown_lt_rc_large %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5)

p_cdf_full_large <- PlotPostCDF(stan_fit_lt_r_imputed_large)
p_cdf_no_lt_large <- PlotPostCDF(stan_fit_no_lt_large)
p_cdf_imp_lt_large <- PlotPostCDF(stan_fit_unknown_lt_rc_large)

p_strong_likelihood_example <- plot_grid(
  p_full_large, p_no_lt_large, p_imp_lt_large,
  p_cdf_full_large, p_cdf_no_lt_large, p_cdf_imp_lt_large,
  nrow = 2,
  ncol = 3
)

p_strong_likelihood_example
```


# Sim study

## Factor levels

```{r}
expected_lifetime <- eta * gamma(1 + (1 / beta))

M_itteration <- 50
# Dataset factors
N_levels <- c(
  10,
  100,
  500
)
t_start_levels <- c(
  round(expected_lifetime * 1, 2),
  round(expected_lifetime * 5, 2),
  round(expected_lifetime * 15, 2)
)
t_window_levels <- c(
  round(expected_lifetime, 2),
  round(expected_lifetime * 3, 2),
  round(expected_lifetime * 6, 2)
)
# Model factors
left_trunc_treatment_levels <- c(
  "known",
  "discarded",
  "imputed"
)
prior_levels <- c(
  "week",
  "strong"
)
```

## Measures of accuracy

Draft of the different measures of accuracy

```{r}
rvar_dweibull <- rfun(dweibull)

example_stan_fit_obj <- stan_fit_lt_r_imputed
test_sets <- lapply(
  1:100,
  function(i) rweibull(100, beta, eta)
)

full_post <- example_stan_fit_obj %>%
  as_draws_rvars()

list(
  p_value_beta = Pr(full_post$beta > beta),
  p_value_eta = Pr(full_post$eta > eta),
  elpd = lapply(
    test_sets,
    function(test_set) {
      rvar_dweibull(
        test_set,
        full_post$beta,
        full_post$eta
      ) %>%
        log() %>%
        rvar_sum() %>%
        E()
    }
  ) %>%
    unlist() %>%
    mean()
)

lapply(
    test_sets,
    function(test_set) {
      dweibull(
        test_set,
        1.1,
        1
      ) %>%
        log() %>%
        sum()
    }
  ) %>%
    unlist() %>%
    mean()
100 * log(dweibull(expected_lifetime, 1.1, 1))
```

```{r}
c(
  dweibull(2, 1.05, 1.04) * dweibull(1, 1.05, 1.04),
  dweibull(2, 1.1, 1) * dweibull(1, 1.1, 1)
) %>% mean() %>% log()

c(
  log(dweibull(2, 1.05, 1.04)) + log(dweibull(1, 1.05, 1.04)),
  log(dweibull(2, 1.1, 1)) + log(dweibull(1, 1.1, 1))
) %>% mean()
```

## Simulations

```{r}
#| label: load-sim-results
experiment_results_df <- readRDS("LT_experiment_results_df.rds")
```

```{r}
#| label: fig-sim-result-factor-plots
GetFactorValue <- function(x) as.numeric(as.character(x))
ModelLabeller <- function(name_string) {
  if (stringr::str_detect(name_string, "stan_fit_imp_lt")) {
    model_name <- "imputed"
  } else if (stringr::str_detect(name_string, "stan_fit_full")) {
    model_name <- "known"
  } else {
    model_name <- "discarded"
  }
  return(model_name)
}
PriorLabeller <- function(name_string) {
  if (stringr::str_detect(name_string, "weak")) {
    prior_name <- "weak"
  } else {
    prior_name <- "strong"
  }
  return(prior_name)
}

experiment_results_df %>%
  mutate(
    model_name = lapply(
      experiment_results_df$model,
      ModelLabeller
    ) %>% unlist(),
    prior_name = lapply(
      experiment_results_df$model,
      PriorLabeller
    ) %>% unlist()
  ) %>%
  ggplot(
    aes(
      x = p_value_beta, y = p_value_eta,
      size = E_log_score, colour = model_name,
      shape = prior_name
    )
  ) +
  geom_point(alpha = 0.5) +
  xlim(0, 1) +
  ylim(0, 1) +
  facet_grid(rows = vars(t_start), cols = vars(N, t_window))
```

```{r}
#| label: fig-sim-result-factor-plots-means
p_sim_result_plot <- experiment_results_df %>%
  mutate(
    model = lapply(
      experiment_results_df$model,
      ModelLabeller
    ) %>% unlist(),
    prior = lapply(
      experiment_results_df$model,
      PriorLabeller
    ) %>% unlist()
  ) %>%
  filter(!is.infinite(E_log_score)) %>%
  group_by(
    N, t_start, t_window, model, prior
  ) %>%
  summarise(
    p_value_beta = mean(p_value_beta, na.rm = TRUE),
    p_value_eta = mean(p_value_eta, na.rm = TRUE),
    elppd = mean(E_log_score, na.rm = TRUE)
  ) %>%
  ggplot(
    aes(
      x = p_value_beta, y = p_value_eta,
      size = elppd, colour = model,
      shape = prior
    )
  ) +
  geom_point(alpha = 0.5) +
  xlim(0, 1) +
  ylim(0, 1) +
  facet_grid(rows = vars(N, t_start), cols = vars(t_window)) +
  xlab(expression(P[beta])) +
  ylab(expression(P[eta])) +
  theme(
    panel.background = element_rect(
      fill = "white", colour = "white"
    ),
    panel.grid.major = element_line(
      size = 0.5,
      colour = alpha("lightgrey", 0.5)
    ),
    panel.grid.minor =  element_line(
      size = 0.25,
      colour = alpha("lightgrey", 0.5)
    ),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank()
  )

p_sim_result_plot
```

```{r}
#| label:save-fig-sim-result-factor-plots-means
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "sim-results-pvalues.pdf"),
  height = 15,
  width = 10
)
p_sim_result_plot
dev.off()
```

```{r}
#| label: fig-sim-result-elppd-plots
experiment_results_df %>%
  mutate(
    model_name = lapply(
      experiment_results_df$model,
      ModelLabeller
    ) %>% unlist(),
    prior_name = lapply(
      experiment_results_df$model,
      PriorLabeller
    ) %>% unlist(),
    N = factor(N)
  ) %>%
  ggplot(
    aes(
      x = N, y = E_log_score,
      colour = model_name,
      shape = prior_name
    )
  ) +
  geom_jitter(
    alpha = 0.5,
    width = 0.25
  ) +
  facet_grid(rows = vars(t_start), cols = vars(t_window))
```

```{r}
#| label: fig-sim-result-elppd-plots-means
p_sim_res_elppd <- experiment_results_df %>%
  mutate(
    model = lapply(
      experiment_results_df$model,
      ModelLabeller
    ) %>% unlist(),
    prior = lapply(
      experiment_results_df$model,
      PriorLabeller
    ) %>% unlist()
  ) %>%
  filter(!is.infinite(E_log_score)) %>%
  group_by(
    N, t_start, t_window, model, prior
  ) %>%
  summarise(
    p_value_beta = mean(p_value_beta, na.rm = TRUE),
    p_value_eta = mean(p_value_eta, na.rm = TRUE),
    elppd = mean(E_log_score, na.rm = TRUE)
  ) %>%
  ggplot(
    aes(
      x = N, y = elppd,
      colour = model,
      shape = prior
    )
  ) +
  geom_jitter(
    alpha = 0.5,
    width = 0.25
  ) +
  facet_grid(rows = vars(t_window), cols = vars(t_start))+
  theme(
    panel.background = element_rect(
      fill = "white", colour = "white"
    ),
    panel.grid.major = element_line(
      size = 0.5,
      colour = alpha("lightgrey", 0.5)
    ),
    panel.grid.minor =  element_line(
      size = 0.25,
      colour = alpha("lightgrey", 0.5)
    ),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank()
  )

p_sim_res_elppd
```

```{r}
#| label:save-fig-sim-result-elppd-plots-means
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "sim-results-elppd.pdf"),
  height = 8.,
  width = 8
)
p_sim_res_elppd
dev.off()
```

# Appendix - A

Demonstration of how the joint posterior of Kaminskey depends on the choise of t_1 or t_2.

```{r}
CalcBetaParams <- function(m, v) {
  a = ((m^2 - m^3) / v) - m
  b = (a / m) - a
  return(list(shape1 = a, shape2 = b))
}
rbetaMeanSd <- function(N, m, v) {
  pars <- CalcBetaParams(m, v)
  random_samp <- rbeta(N, pars$shape1, pars$shape2)
  return(random_samp)
}
# Define elicitation and observation times
t_1 <- qweibull(0.3, beta, eta)
t_2 <- qweibull(0.7, beta, eta)
t_3 <- qweibull(0.2, beta, eta)

# Generate samples from the joint prior
prior <- data.frame(
  F1 = rbetaMeanSd(10000, 0.3, 0.05),
  F2 = rbetaMeanSd(10000, 0.7, 0.02)
) %>%
  filter(F2 > F1) %>%
  mutate(
    beta = (fn(F2) - fn(F1)) / log(t_2 / t_1),
    eta = exp(log(t_1) - (fn(F1) / beta)),
    F3_prior = pweibull(t_3, beta, eta)
  )
# Calculate coresponding values of beta distribution at t_3
F3_prior_params <- CalcBetaParams(
  m = mean(prior$F3_prior),
  v = var(prior$F3_prior)
)
# Generate some binomial data from true data generateing process
binom_data <- rbinom(
  n = 1,
  size = 10,
  prob = 0.2
)
# Calculate posterior of P at t_3
shape1_post <- F3_prior_params$shape1 + binom_data
shape2_post <- F3_prior_params$shape2 + (10 - binom_data)
# Generate samples from joint post using t_2
post1 <- data.frame(
  F3_post = rbeta(10000, shape1_post, shape2_post),
  F2 = rbetaMeanSd(10000, 0.7, 0.02)
) %>%
  filter(F2 > F3_post) %>%
  mutate(
    beta = (fn(F2) - fn(F3_post)) / log(t_2 / t_3),
    eta = exp(log(t_3) - (fn(F3_post) / beta))
  )
p1 <- post1 %>%
  ggplot(aes(x = beta, y = eta)) +
  geom_point() +
  ylim(0, 10) +
  xlim(0, 10)
# Generate samples from joint post using t_1
post2 <- data.frame(
  F3_post = rbeta(10000, shape1_post, shape2_post),
  F1 = rbetaMeanSd(10000, 0.3, 0.05)
) %>%
  filter(F1 > F3_post) %>%
  mutate(
    beta = (fn(F1) - fn(F3_post)) / log(t_1 / t_3),
    eta = exp(log(t_3) - (fn(F3_post) / beta))
  )
p2 <- post2 %>%
  ggplot(aes(x = beta, y = eta)) +
  geom_point() +
  ylim(0, 10) +
  xlim(0, 10)
# Compare the two posteriors
cowplot::plot_grid(p1, p2, nrow = 1, ncol = 2)
```

# Appendix - B


```{r}
stan_model_test <- stan_model(
  model_code = "
data {
int C;                                 # Number of chains
int N_obs;                             # N fully observed lives
int N_rc;                              # N right censored only lives
int N_lt;                              # N left truncated only lives
int N_lt_rc;                           # N right cens and left trunc lives
array[N_obs] real<lower=0> y_obs;      # Fully observed lifetimes
array[N_rc] real<lower=0> y_rc;        # Right censored lifetimes
array[N_lt] real<lower=0> y_lt;        # Left trunc lifetimes
array[N_lt_rc] real<lower=0> y_lt_rc;  # right cens and left trunc lifetimes
real<lower=0> t_start;                 # start of the observation window
vector[N_lt_rc] t_lt_rc_st_chains[C];  # Uniformsampling work around
int<lower=1, upper=C> CHAIN_ID;
}
transformed data{
array[N_lt] real<lower=0> y_lt_upper;  # The upper bound of the left trunc lives
vector[N_lt_rc] t_lt_rc_st;

print(\"Running chain \", CHAIN_ID);
t_lt_rc_st = t_lt_rc_st_chains[CHAIN_ID, ];

for (m in 1:N_lt){
  y_lt_upper[m] = y_lt[m] + t_start;   # Upper bound = lower bound + start of observation
}

}
parameters {
real<lower= 0> beta;     # weibull shape
real<lower= 0> eta;      # weibull scale
array[N_rc] real<lower=y_rc> y_rc_hat;   # imputed right censored values
array[N_lt] real<lower=y_lt, upper=y_lt_upper> y_lt_hat;  # imputed left trunc values
array[N_lt_rc] real<lower=y_lt_rc> y_lt_rc_hat;   # imputed left trunc and right cens values
}
transformed parameters{
array[N_lt] real t_lt;  # imputed left trunc times for left trunc values
array[N_lt_rc] real<lower=0, upper=t_start> t_lt_rc_upper;
array[N_lt_rc] real<lower=0, upper=t_lt_rc_upper> t_lt_rc;  # imputed left trunc times for left trunc and right cens values


for (i in 1:N_lt) {
  t_lt[i] = y_lt_hat[i] - y_lt[i];
}

for (k in 1:N_lt_rc){
  if ((y_lt_rc_hat[k] - y_lt_rc[k]) < t_start)
    t_lt_rc_upper[k] = y_lt_rc_hat[k] - y_lt_rc[k];
  else
    t_lt_rc_upper[k] = t_start;

  t_lt_rc[k] = t_lt_rc_st[k] * t_lt_rc_upper[k];
}
}
model{

// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt_hat[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}
// left truncated and right censored lifetimes
for (j in 1:N_lt_rc) {
  y_lt_rc_hat[j] ~ weibull(beta, eta) T[t_lt_rc[j], ]; 
}

// Prior model
eta ~ normal(1, 1);
beta ~ normal(1.1, 1);
}

"
)
```


```{r}
C <- 50
t_lt_rc_st_chains <- array(
  runif(C * stan_data_unkown_lt_large$N_lt_rc),
  dim = c(C, stan_data_unkown_lt_large$N_lt_rc)
)
stan_fit_test <- sampling(
  stan_model_test,
  c(
    stan_data_unkown_lt_large,
    list(
      C = C,
      t_lt_rc_st_chains = t_lt_rc_st_chains
    )
  ),
  chains = C,
  iter = 400,
  warmup = 300,
  chain_id = 1L
)
```


```{r}
p1 <- stan_fit_test %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5)
```


```{r}
stan_fit_test %>%
  as_draws_rvars() %>%
  spread_draws(t_lt_rc[i], t_lt_rc_upper[i]) %>%
  mutate(
    t_lt_rc_st =  t_lt_rc / t_lt_rc_upper
  ) %>%
  filter(i == 1) %>%
  pull(t_lt_rc_st) %>%
  unique()
  ggplot() +
  geom_histogram(aes(t_lt_rc_st)) 
  
  mcmc_hist(
    pars = "t_lt_rc[1]"
  )
```


```{r}
stan_fit_unknown_lt_rc <- sampling(
  stan_model_unknown_lt_rc,
  stan_data_unkown_lt_large,
  chains = 4,
  iter = 1000,
  warmup = 300
)

p2 <- stan_fit_unknown_lt_rc %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5)

cowplot::plot_grid(
  p1, p2,
  nrow = 1, ncol = 2
)
```

```{r}
stan_fit_unknown_lt_rc %>%
  mcmc_hist(
    pars = stringr::str_c("t_lt_rc_st[", 1:10, "]")
  )
```



```{r}
test_stan_model <- stan_model(
  model_code = "
data{
int N_o;
int N_r;
int N_l;
int N_lr;
array[N_o] real<lower=0> y_o;
array[N_r] real<lower=0> y_r;
array[N_l] real<lower=0> y_l;
array[N_lr] real<lower=0> y_lr;
real<lower = 0> t_start;
}
transformed data{
array[N_l] real<lower = 0> y_l_ub;
for (n_l_d in 1:N_l) {
  y_l_ub[n_l_d] = y_l[n_l_d] + t_start;
}
}
parameters {
real<lower = 0> beta;
real<lower = 0> eta;
array[N_r] real<lower = y_r> y_r_hat;
array[N_l] real<lower = y_l, upper = y_l_ub> y_l_hat;
array[N_lr] real<lower = y_lr> y_lr_hat;
array[N_lr] real<lower = 0, upper = 1> t_lr_st;
}
transformed parameters {
array[N_l] real<lower = 0> t_l;
array[N_lr] real<lower = 0, upper = t_start> t_lr_ub;
array[N_lr] real<lower = 0, upper = t_lr_ub> t_lr_hat;

for (n_l_p in 1:N_l) {
  t_l[n_l_p] = y_l_hat[n_l_p] - y_l[n_l_p];
}

for (n_lr_p in 1:N_lr) {
  if ((y_lr_hat[n_lr_p] - y_lr[n_lr_p]) < t_start)
    t_lr_ub[n_lr_p] = (y_lr_hat[n_lr_p] - y_lr[n_lr_p]);
  else 
    t_lr_ub[n_lr_p] = t_start;
  t_lr_hat[n_lr_p] = t_lr_st[n_lr_p] * t_lr_ub[n_lr_p];
}

}
model {
beta ~ normal(1.1, 1);
eta ~ normal(1, 1);
t_lr_st ~ uniform(0, 1);

target += weibull_lpdf(y_o | beta, eta);
target += weibull_lpdf(y_r_hat | beta, eta);
target += weibull_lpdf(y_l_hat | beta, eta) - weibull_lccdf(t_l | beta, eta);
target += weibull_lpdf(y_lr_hat | beta, eta) - weibull_lccdf(t_lr_hat | beta, eta);
}
"
)
```


```{r}
test_stan_data <- list(
  N_o = nrow(sim_df_obs),
  N_r = nrow(sim_df_rc),
  N_l = nrow(sim_df_lt),
  N_lr = nrow(sim_df_lt_rc),
  y_o = sim_df_obs$failure_time - sim_df_obs$install_time,
  y_r = sim_df_rc$failure_time_obs - sim_df_rc$install_time_obs,
  y_l = sim_df_lt$failure_time_obs - sim_df_lt$install_time_obs,
  y_lr = sim_df_lt_rc$failure_time_obs - sim_df_lt_rc$install_time_obs,
  t_start = t_start
)
stan_fit_unknown_lt_rc <- sampling(
  test_stan_model,
  test_stan_data,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  control = list(adapt_delta = 0.99, max_treedepth = 14)
)
```
---
title: "Main analysis ch2"
format:
  html:
    embed-resources: true
    self-contained-math: true
editor: source
cache: false
warning: false
message: false
---

This markdown contains the code to reproduce the main analysis in chapter 2. The 

```{r}
#| label: set-up-chunk
#| code-fold: true
#| code-summary: "Show setup chunk"
library(dplyr)
library(ggplot2)
library(ggdist)
library(cowplot)
library(rstan)
library(posterior)
library(tidybayes)
library(bayesplot)
library(kableExtra)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

fig_path <- file.path(
  "..",
  "..",
  "figures",
  "ch-2"
)
tbl_path <- file.path(
  "..",
  "..",
  "tables",
  "ch-2"
)
```

```{r}
#| label: define-functions
#| code-fold: true
#| code-summary: "Show runctions chunk"
# Function to sample from a truncated normal distribution
rTruncNorm <- function(n, mean, sd, lb = NULL, ub = NULL) {
  # Check if lower bound is supplied & 
  # calculate lower bound of uniform dist
  if (!is.null(lb)) {
    lb_unif <- pnorm((lb - mean) / sd)
  } else {
    lb_unif <- 0
  }
  if (!is.null(ub)) {
    ub_unif <- pnorm((ub - mean) / sd)
  } else {
    ub_unif <- 1
  }
  # Sample from uniform distribution
  unif_rv <- runif(n, lb_unif, ub_unif)
  # Probability integral transformation
  norm_rv <- (qnorm(unif_rv) * sd) + mean
  
  return(norm_rv)
}
# function used to calculate weibull draws in joint prior
fn <- function(x) {
  log(-log(1 - x))
}
# function to plot the posterior CDF
PlotPostCDF <- function(stan_fit, x_range = c(0, 5), res = 0.05) {
  grid <- seq(x_range[1], x_range[2], 0.01)
  p_cdf <- stan_fit %>%
    as_draws_df() %>%
    select(beta, eta) %>%
    split(., seq(nrow(.))) %>%
    lapply(
      function(draw) {
        df_CDF <- data.frame(
          q = grid,
          p = pweibull(grid, draw$beta, draw$eta)
        )
        return(df_CDF)
      }
    ) %>%
    bind_rows() %>%
    ggplot() +
    stat_lineribbon(
      aes(x = q, y = p),
      .width = c(0.5, 0.9)
    ) +
    scale_fill_brewer() +
    geom_function(
      fun = pweibull,
      args = list(shape = beta, scale = eta),
      colour = "red"
    ) +
    xlab("t") +
    ylab("cdf") +
    theme_minimal() +
    theme(legend.position = "none")
    return(p_cdf)
}
```

```{r}
#| label: define-true-weibull-params
beta <- 1.1
eta <- 1
```

# Informative prior demonstration

Using the methods of keminskey we can encode a joint prior for the Weibull parameters by eliciting information about the CDF. This is much more intuitive than eliciting information about the parameters directly. The result is covariance in the joint posterior that encodes where we are uncertain. This is usefull in cases where the data are uninformative about some areas of the CDF but we do not want to impose a strong prior on the areas that the data are able to inform; for example right censoring masks longer lifetimes and so we can inject information through the joint prior to inform the upper tail of the distribution while still allowing the data to update the lower tail.

```{r}
#| label: fig-joint-priors
#| fig-cap: "Three different informative joint priors constructed using the method of @kaminskiy2005. The joint draws of the parameters are shown in the top row---(a), (b), and (c)---and the corresponding uncertainty in the CDF is shown in the bottom---(d), (e), and (f). (a) and (d) show a prior where information is elicited around the t_1 = 0.07 and t_2 = 0.26 (the 0.05 and 0.20 quantiles of the true distribution Weibull(1.1, 1), (b) and (e) show a prior where information is elicited around the t_1 = 0.46 and t_2 = 1.04 (the 0.35 and 0.65 quantiles), and (c) and (f) show a prior elicited at t_1 = 1.54 and t_2 = 2.71 (the 0.80 and 0.95 quantiles)."
set.seed(567)
pp1s <- c(0.05, 0.35, 0.80)
pp2s <- c(0.20, 0.65, 0.95)
sds1 <- c(0.02, 0.04, 0.04)
sds2 <- c(0.04, 0.04, 0.02)
t1s <- lapply(
  pp1s,
  function(p) qweibull(p, beta, eta)
) %>%
  unlist()
t2s <- lapply(
  pp2s,
  function(p) qweibull(p, beta, eta)
) %>%
  unlist()

p_priors <- lapply(
  1:3,
  function(i) {
    n_draws <- 1000
    x_range <- c(0, 5)
    res <- 0.1
    # sample values of cdf
    samp_t1 <- rTruncNorm(
      n = n_draws,
      mean = pp1s[i], sd = sds1[i],
      lb = 0, ub = 1
    )
    samp_t2 <- rTruncNorm(
      n = n_draws,
      mean = pp2s[i], sd = sds2[i],
      lb = samp_t1, ub = 1
    )
    # calculate Weibull parameters
    beta_sample <- (fn(samp_t2) - fn(samp_t1)) / log(t2s[i] / t1s[i])
    eta_sample <- exp(log(t1s[i]) - (fn(samp_t1) / beta_sample))
    # plot joint dist and CDF
    cdf_grid <- seq(x_range[1], x_range[2], by = res)
    p_joint <- data.frame(
      beta = beta_sample,
      eta = eta_sample
    ) %>%
      ggplot() +
      geom_point(
        aes(x = beta_sample, y = eta_sample)
      ) +
      geom_point(
        x = beta,
        y = eta,
        col = "red"
      ) +
      xlim(0, 3) +
      ylim(0, 3) +
      xlab(expression(beta)) +
      ylab(expression(eta)) +
      theme_minimal()
    p_cdf <- data.frame(
      draw = rep(1:n_draws, each = length(cdf_grid)),
      t = rep(cdf_grid, n_draws)
    ) %>%
      mutate(
        cdf = pweibull(t, beta_sample[draw], eta_sample[draw])
      ) %>%
      ggplot() +
      stat_lineribbon(
        aes(x = t, y = cdf),
        .width = c(0.5, 0.9)
      ) +
      scale_fill_brewer() +
      geom_function(
        fun = pweibull,
        args = list(shape = beta, scale = eta),
        colour = "red"
      ) +
      theme_minimal() +
      theme(legend.position = "none")
      return(
        list(joint = p_joint, cdf = p_cdf)
      )
  }
)

p_joint_priors <- plot_grid(
  p_priors[[1]]$joint, p_priors[[2]]$joint, p_priors[[3]]$joint,
  p_priors[[1]]$cdf, p_priors[[2]]$cdf, p_priors[[3]]$cdf,
  nrow = 2,
  ncol = 3,
  labels = c(
    "(a)", "(b)", "(c)",
    "(d)", "(e)", "(f)"
  ),
  label_fontfamily = "Times",
  label_face = "plain"
)
p_joint_priors
```

```{r}
#| label: save-fig-joint-priors
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "joint-priors.pdf"),
  height = 6,
  width = 8
)
p_joint_priors
dev.off()
```

# Simulating data

```{r}
#| label: define-sim-params
N_units <- 10
t_start <- 5
t_window <- 1
t_end <- t_start + t_window
```


```{r}
#| label: function-SimData
SimData <- function(
  beta,
  eta,
  n_units,
  t_start,
  t_end
){
  # Calculate how many lifetimes to sample
  weibull_05_quant <- qweibull(0.05, shape = beta, scale = eta)
  n_lifetimes_per_unit <- ceiling(t_end / weibull_05_quant) * 2

  # Create simulation data frame
  small_sim <- data.frame(
      # Define units
      unit = factor(
        rep(1:n_units, each = n_lifetimes_per_unit),
        1:n_units
      ),
      # Sample for Weibull distribution
      lifetime = rweibull(
        n_units * n_lifetimes_per_unit,
        shape = beta,
        scale = eta
      )
    ) %>% 
    group_by(unit) %>%
    # Calculate the failure times and install times
    mutate(
      failure_time = cumsum(lifetime),
      install_time = lag(failure_time),
      lifetime_id = 1:n()
    ) %>%
    ungroup() %>%
    # Replace NAs created by lag() with t = 0
    replace(is.na(.), 0) %>%
    # Discard any lifetimes that didn't fail or within the observation period
    filter(
      between(install_time, t_start, t_end) |
      between(failure_time, t_start, t_end) |
      ((install_time < t_start) & (failure_time > t_end))
    ) %>%
    # Create right and interval censoring indicator variables
    mutate(
      int_censored = !between(install_time, t_start, t_end),
      right_censored = !between(failure_time, t_start, t_end),
      install_time_obs = ifelse(int_censored, t_start, install_time),
      failure_time_obs = ifelse(right_censored, t_end, failure_time)
    )

  return(small_sim)
}
```

```{r}
#| label: tbl-sim-data
#| tbl-cap: "The simulated data from a Weibull distribution with beta = 1.1 and eta = 1."
set.seed(549)
sim_df <- SimData(
  beta = beta,
  eta = eta,
  n_units = N_units,
  t_start = t_start,
  t_end = t_end
)

sim_df %>%
  kbl() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

```{r}
#| label: save-tbl-sim-data
#| echo: false
#| output: false
sim_df_latex <- sim_df %>%
  select(-c("lifetime_id", "int_censored", "right_censored"))
colnames(sim_df_latex) <- c(
  "Unit",
  "Lifetime",
  "True failure",
  "True install",
  "Observed install",
  "Observed failure"
)

sim_df_latex %>%
  mutate(across(-c("Unit"), ~ round(.x, 2))) %>%
  kbl(
    booktabs = T,
    format = "latex",
    caption = "The simulated CMMS data for ten units.",
    escape = FALSE,
    label = "sim-cmms-data"
  ) %>%
  kable_styling(latex_options = "striped") %>%
  save_kable(
    file = file.path(
      tbl_path,
      "sim_cmms_data.tex"
    ),
    keep_tex = TRUE
  )
```

```{r}
#| label: fig-sim-data
#| fig-cap: "The simulated data from a Weibull distribution with beta = 1.1 and eta = 1."
p_sim_data <- sim_df %>%
  mutate(i = 1:n()) %>%
  ggplot() +
  geom_segment(
    aes(x = install_time, y = i, xend = failure_time, yend = i),
    colour = "gray",
    linetype = 2
  ) +
  geom_segment(
    aes(x = install_time_obs, y = i, xend = failure_time_obs, yend = i),
    colour = "black",
    linetype = 1
  ) +
  geom_vline(xintercept = c(t_start, t_end), colour = "red", linetype = "dashed") +
  theme_minimal() +
  xlab("t") +
  ylab("") +
  theme(
    axis.text.y=element_blank(), 
    axis.ticks.y=element_blank()
  )

p_sim_data
```

```{r}
#| label: save-fig-sim-data
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "sim-data.pdf"),
  height = 6,
  width = 6
)
p_sim_data
dev.off()
```

```{r}
#| label: prep-stan-data
sim_df_obs <- sim_df %>%
  filter(!(right_censored | int_censored))
sim_df_rc <- sim_df %>%
  filter(right_censored & !int_censored)
sim_df_lt <- sim_df %>%
  filter(!right_censored & int_censored)
sim_df_lt_rc <- sim_df %>%
  filter(right_censored & int_censored)

stan_data_full <- list(
  N_obs = nrow(sim_df_obs),
  N_rc = nrow(sim_df_rc),
  N_lt = nrow(sim_df_lt),
  N_lt_rc = nrow(sim_df_lt_rc),
  y_obs = sim_df_obs$failure_time - sim_df_obs$install_time,
  y_rc = sim_df_rc$failure_time_obs - sim_df_rc$install_time,
  y_lt = sim_df_lt$failure_time - sim_df_lt$install_time,
  t_lt = sim_df_lt$install_time_obs - sim_df_lt$install_time,
  y_lt_rc = sim_df_lt_rc$failure_time_obs - sim_df_lt_rc$install_time,
  t_lt_rc = sim_df_lt_rc$install_time_obs - sim_df_lt_rc$install_time
)

stan_data_no_lt <- list(
  N_obs = nrow(sim_df_obs),
  N_rc = nrow(sim_df_rc),
  y_obs = sim_df_obs$failure_time - sim_df_obs$install_time,
  y_rc = sim_df_rc$failure_time_obs - sim_df_rc$install_time
)

stan_data_unkown_lt <- list(
  N_obs = nrow(sim_df_obs),
  N_rc = nrow(sim_df_rc),
  N_lt = nrow(sim_df_lt),
  N_lt_rc = nrow(sim_df_lt_rc),
  y_obs = sim_df_obs$failure_time - sim_df_obs$install_time,
  y_rc = sim_df_rc$failure_time_obs - sim_df_rc$install_time_obs,
  y_lt = sim_df_lt$failure_time_obs - sim_df_lt$install_time_obs,
  y_lt_rc = sim_df_lt_rc$failure_time_obs - sim_df_lt_rc$install_time_obs,
  t_start = t_start
)
```

## Stan models (weakly informative)

::: panel-tabset
### Known truncation times

```{r}
#| label: known-trunc-stan-model
stan_model_lt_r_imputed <- stan_model(
  model_code = "
data {
int N_obs;
int N_rc;
int N_lt;
int N_lt_rc;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
vector<lower=0>[N_lt] y_lt;
vector<lower=0>[N_lt] t_lt;
vector<lower=0>[N_lt_rc] y_lt_rc;
vector<lower=0>[N_lt_rc] t_lt_rc;
}
parameters {
real<lower = 0> beta;
real<lower = 0> eta;
vector<lower = y_rc>[N_rc] y_rc_hat;
vector<lower = y_lt_rc>[N_lt_rc] y_lt_rc_hat;
}
model{
// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}
// left truncated and right censored lifetimes
for (j in 1:N_lt_rc) {
  y_lt_rc_hat[j] ~ weibull(beta, eta) T[t_lt_rc[j], ]; 
}

// Prior model
eta ~ normal(1, 1);
beta ~ normal(1.1, 1);
}

"
)
```

### No truncated samples
```{r}
#| label: discarded-trunc-stan-model
stan_model_no_lt <- stan_model(
  model_code = "
data {
int N_obs;
int N_rc;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
}
parameters {
real<lower = 0> beta;
real<lower = 0> eta;
}
model{
// Data model
// fully observed lifetimes
target += weibull_lpdf(y_obs|beta, eta);
// right censored lifetimes
target += weibull_lccdf(y_rc|beta, eta);

// Prior model
eta ~ normal(1, 1);
beta ~ normal(1.1, 1);
}

"
)
```

### Impute truncation times
```{r}
#| label: imputed-trunc-stan-model
stan_model_unknown_lt_rc <- stan_model(
  model_code = "
data {
int N_obs;                             # N fully observed lives
int N_rc;                              # N right censored only lives
int N_lt;                              # N left truncated only lives
int N_lt_rc;                           # N right cens and left trunc lives
array[N_obs] real<lower=0> y_obs;      # Fully observed lifetimes
array[N_rc] real<lower=0> y_rc;        # Right censored lifetimes
array[N_lt] real<lower=0> y_lt;        # Left trunc lifetimes
array[N_lt_rc] real<lower=0> y_lt_rc;  # right cens and left trunc lifetimes
real<lower=0> t_start;                 # start of the observation window
}
transformed data{
array[N_lt] real<lower=0> y_lt_upper;  # The upper bound of the left trunc lives

for (m in 1:N_lt){
  y_lt_upper[m] = y_lt[m] + t_start;   # Upper bound = lower bound + start of observation
}

}
parameters {
real<lower= 0> beta;     # weibull shape
real<lower= 0> eta;      # weibull scale
array[N_rc] real<lower=y_rc> y_rc_hat;   # imputed right censored values
array[N_lt] real<lower=y_lt, upper=y_lt_upper> y_lt_hat;  # imputed left trunc values
array[N_lt_rc] real<lower=y_lt_rc> y_lt_rc_hat;   # imputed left trunc and right cens values
array[N_lt_rc] real<lower=0, upper=1> t_lt_rc_st; # imputed left truncation times for left trunc and right cens values (standardised)
}
transformed parameters{
array[N_lt] real t_lt;  # imputed left trunc times for left trunc values
array[N_lt_rc] real<lower=0, upper=t_start> t_lt_rc_upper;
array[N_lt_rc] real<lower=0, upper=t_lt_rc_upper> t_lt_rc;  # imputed left trunc times for left trunc and right cens values

for (i in 1:N_lt) {
  t_lt[i] = y_lt_hat[i] - y_lt[i];
}

for (k in 1:N_lt_rc){
  if ((y_lt_rc_hat[k] - y_lt_rc[k]) < t_start)
    t_lt_rc_upper[k] = y_lt_rc_hat[k] - y_lt_rc[k];
  else
    t_lt_rc_upper[k] = t_start;

  t_lt_rc[k] = t_lt_rc_st[k] * t_lt_rc_upper[k];
}
}
model{
// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt_hat[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}
// left truncated and right censored lifetimes
for (j in 1:N_lt_rc) {
  y_lt_rc_hat[j] ~ weibull(beta, eta) T[t_lt_rc[j], ]; 
}

// Prior model
eta ~ normal(1, 1);
beta ~ normal(1.1, 1);
t_lt_rc_st ~ uniform(0, 1);
}

"
)
```
:::

### Sampling

I draw $2000$ sample from the posteriors of each model, using four chains with a burn in of $500$ samples and no thinning.

::: panel-tabset
#### Known truncation times
```{r}
#| label: fit-lt-known-model
stan_fit_lt_r_imputed <- sampling(
  stan_model_lt_r_imputed,
  stan_data_full,
  chains = 4,
  iter = 1000,
  warmup = 500
)
```

#### No truncated samples
```{r}
#| label: fit-lt-discarded-model
stan_fit_no_lt <- sampling(
  stan_model_no_lt,
  stan_data_no_lt,
  chains = 4,
  iter = 1000,
  warmup = 500
)
```

#### Impute truncation times
```{r}
#| label: fit-lt-imputed-model
stan_fit_unknown_lt_rc <- sampling(
  stan_model_unknown_lt_rc,
  stan_data_unkown_lt,
  chains = 4,
  iter = 1000,
  warmup = 500
)
```
:::

```{r}
#| label: fig-join-posts
#| fig-cap: "The draws from the joint posteriors conditioned on the simulated dataset when the left-truncated lifetimes are fully observed (a), discarded (b), or imputed (c) and a weakly informative prior is used. (d), (e), and (f) show the corresponding uncertainty around the CDF (in the form of the 0.5 and 0.8 uncertain intervals) that result from (a), (b), and (c), respectively. The true parameter values and CDF are shown in red."
p_full <- stan_fit_lt_r_imputed %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5) +
  xlab(expression(beta)) +
  ylab(expression(eta)) +
  theme_minimal()
p_no_lt <- stan_fit_no_lt %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5) +
  xlab(expression(beta)) +
  ylab(expression(eta)) +
  theme_minimal()
p_imp_lt <- stan_fit_unknown_lt_rc %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5) +
  xlab(expression(beta)) +
  ylab(expression(eta)) +
  theme_minimal()

p_cdf_full <- PlotPostCDF(stan_fit_lt_r_imputed)
p_cdf_no_lt <- PlotPostCDF(stan_fit_no_lt)
p_cdf_imp_lt <- PlotPostCDF(stan_fit_unknown_lt_rc)

p_joint_posts <- plot_grid(
  p_full, p_no_lt, p_imp_lt,
  p_cdf_full, p_cdf_no_lt, p_cdf_imp_lt,
  nrow = 2,
  ncol = 3,
  labels = c(
    "(a)", "(b)", "(c)",
    "(d)", "(e)", "(f)"
  ),
  label_fontfamily = "Times",
  label_face = "plain"
)
p_joint_posts
```

```{r}
#| label: save-fig-join-posts
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "joint-posts.pdf"),
  height = 5,
  width = 10
)
p_joint_posts
dev.off()
```

## Stan models (informative)

Now I fit the models with an informative joint prior, eliciting information at $t_1 = p_{0.80} = 1.54$ and $t_2 = p_{0.95} = 2.71$. The prior is 
$$
\begin{align*}
    \hat{F}_{t_1} \sim & \hbox{N}^{1}_{0}\left(0.8, 0.1\right)    \\
    \hat{F}_{t_2} \sim & \hbox{N}^{1}_{0}\left(0.95, 0.05\right).
\end{align*}
$$

The prior is specified around the true model used to simulate the data.

::: panel-tabset
### Known truncation times

```{r}
#| label: known-trunc-stan-model-inf
stan_model_lt_r_imputed_inf <- stan_model(
  model_code = "
functions {
// function to simplify the calculation of eta and beta
real fn(real tCDF) {
  return log(-log1m(tCDF));
}
}
data {
int N_obs;
int N_rc;
int N_lt;
int N_lt_rc;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
vector<lower=0>[N_lt] y_lt;
vector<lower=0>[N_lt] t_lt;
vector<lower=0>[N_lt_rc] y_lt_rc;
vector<lower=0>[N_lt_rc] t_lt_rc;
// Define the prior
real t_1;
real t_2;
real t1_mean;
real t1_var;
real t2_mean;
real t2_var;
}
parameters {
real<lower = 0, upper = 1> t1CDF;
real<lower = t1CDF, upper = 1> t2CDF;
vector<lower = y_rc>[N_rc] y_rc_hat;
vector<lower = y_lt_rc>[N_lt_rc] y_lt_rc_hat;
}
transformed parameters {
real<lower = 0> beta;
real<lower = 0> eta;

// calculate Weibull paramaters based on the
// draws from the CDF at t1 and t2.
beta = (fn(t2CDF) - fn(t1CDF)) / log(t_2 / t_1);
eta = exp(log(t_1) - (fn(t1CDF) / beta));
}
model{
// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}
// left truncated and right censored lifetimes
for (j in 1:N_lt_rc) {
  y_lt_rc_hat[j] ~ weibull(beta, eta) T[t_lt_rc[j], ]; 
}

// Prior model
t1CDF ~ normal(t1_mean, t1_var);
t2CDF ~ normal(t2_mean, t2_var);
}

"
)
```

### No truncated samples
```{r}
#| label: discarded-trunc-stan-model-inf
stan_model_no_lt_inf <- stan_model(
  model_code = "
functions {
// function to simplify the calculation of eta and beta
real fn(real tCDF) {
  return log(-log1m(tCDF));
}
}
data {
int N_obs;
int N_rc;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
// Define the prior
real t_1;
real t_2;
real t1_mean;
real t1_var;
real t2_mean;
real t2_var;
}
parameters {
real<lower = 0, upper = 1> t1CDF;
real<lower = t1CDF, upper = 1> t2CDF;
}
transformed parameters {
real<lower = 0> beta;
real<lower = 0> eta;

// calculate Weibull paramaters based on the
// draws from the CDF at t1 and t2.
beta = (fn(t2CDF) - fn(t1CDF)) / log(t_2 / t_1);
eta = exp(log(t_1) - (fn(t1CDF) / beta));
}
model{
// Data model
// fully observed lifetimes
target += weibull_lpdf(y_obs|beta, eta);
// right censored lifetimes
target += weibull_lccdf(y_rc|beta, eta);

// Prior model
t1CDF ~ normal(t1_mean, t1_var);
t2CDF ~ normal(t2_mean, t2_var);
}

"
)
```

### Impute truncation times
```{r}
#| label: imputed-trunc-stan-model-inf
stan_model_unknown_lt_rc_inf <- stan_model(
  model_code = "
functions {
// function to simplify the calculation of eta and beta
real fn(real tCDF) {
  return log(-log1m(tCDF));
}
}
data {
int N_obs;                             # N fully observed lives
int N_rc;                              # N right censored only lives
int N_lt;                              # N left truncated only lives
int N_lt_rc;                           # N right cens and left trunc lives
array[N_obs] real<lower=0> y_obs;      # Fully observed lifetimes
array[N_rc] real<lower=0> y_rc;        # Right censored lifetimes
array[N_lt] real<lower=0> y_lt;        # Left trunc lifetimes
array[N_lt_rc] real<lower=0> y_lt_rc;  # right cens and left trunc lifetimes
real<lower=0> t_start;                 # start of the observation window
// Define the prior
real t_1;
real t_2;
real t1_mean;
real t1_var;
real t2_mean;
real t2_var;
}
transformed data{
array[N_lt] real<lower=0> y_lt_upper;  # The upper bound of the left trunc lives

for (m in 1:N_lt){
  y_lt_upper[m] = y_lt[m] + t_start;   # Upper bound = lower bound + start of observation
}

}
parameters {
real<lower = 0, upper = 1> t1CDF;
real<lower = t1CDF, upper = 1> t2CDF;
array[N_rc] real<lower=y_rc> y_rc_hat;   # imputed right censored values
array[N_lt] real<lower=y_lt, upper=y_lt_upper> y_lt_hat;  # imputed left trunc values
array[N_lt_rc] real<lower=y_lt_rc> y_lt_rc_hat;   # imputed left trunc and right cens values
array[N_lt_rc] real<lower=0, upper=1> t_lt_rc_st; # imputed left truncation times for left trunc and right cens values (standardised)
}
transformed parameters{
real<lower = 0> beta;
real<lower = 0> eta;
array[N_lt] real t_lt;  # imputed left trunc times for left trunc values
array[N_lt_rc] real<lower=0, upper=t_start> t_lt_rc_upper;
array[N_lt_rc] real<lower=0, upper=t_lt_rc_upper> t_lt_rc;  # imputed left trunc times for left trunc and right cens values

// calculate Weibull paramaters based on the
// draws from the CDF at t1 and t2.
beta = (fn(t2CDF) - fn(t1CDF)) / log(t_2 / t_1);
eta = exp(log(t_1) - (fn(t1CDF) / beta));

for (i in 1:N_lt) {
  t_lt[i] = y_lt_hat[i] - y_lt[i];
}

for (k in 1:N_lt_rc){
  if ((y_lt_rc_hat[k] - y_lt_rc[k]) < t_start)
    t_lt_rc_upper[k] = y_lt_rc_hat[k] - y_lt_rc[k];
  else
    t_lt_rc_upper[k] = t_start;

  t_lt_rc[k] = t_lt_rc_st[k] * t_lt_rc_upper[k];
}
}
model{
// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt_hat[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}
// left truncated and right censored lifetimes
for (j in 1:N_lt_rc) {
  y_lt_rc_hat[j] ~ weibull(beta, eta) T[t_lt_rc[j], ]; 
}

// Prior model
t1CDF ~ normal(t1_mean, t1_var);
t2CDF ~ normal(t2_mean, t2_var);
t_lt_rc_st ~ uniform(0, 1);
}

"
)
```
:::

### Sampling

::: panel-tabset
#### Known truncation times
```{r}
#| label: fit-lt-known-model-inf
stan_fit_lt_r_imputed_inf <- sampling(
  stan_model_lt_r_imputed_inf,
  c(
    stan_data_full,
    t_1 = qweibull(0.8, beta, eta),
    t_2 = qweibull(0.95, beta, eta),
    t1_mean = 0.8,
    t1_var = 0.1,
    t2_mean = 0.95,
    t2_var = 0.05
  ),
  chains = 4,
  cores = 4,
  iter = 1000,
  warmup = 500
)
```

#### No truncated samples
```{r}
#| label: fit-lt-discarded-model-inf
stan_fit_no_lt_inf <- sampling(
  stan_model_no_lt_inf,
  c(
    stan_data_no_lt,
    t_1 = qweibull(0.8, beta, eta),
    t_2 = qweibull(0.95, beta, eta),
    t1_mean = 0.8,
    t1_var = 0.1,
    t2_mean = 0.95,
    t2_var = 0.05
  ),
  chains = 4,
  cores = 4,
  iter = 1000,
  warmup = 500
)
```

#### Impute truncation times
```{r}
#| label: fit-lt-imputed-model-inf
stan_fit_unknown_lt_rc_inf <- sampling(
  stan_model_unknown_lt_rc_inf,
  c(
    stan_data_unkown_lt,
    t_1 = qweibull(0.8, beta, eta),
    t_2 = qweibull(0.95, beta, eta),
    t1_mean = 0.8,
    t1_var = 0.1,
    t2_mean = 0.95,
    t2_var = 0.05
  ),
  chains = 4,
  cores = 4,
  iter = 1000,
  warmup = 500
)
```
:::

```{r}
#| label: fig-join-posts-inf
#| fig-cap: "The draws from the joint posteriors conditioned on the simulated dataset when the left-truncated lifetimes are fully observed (a), discarded (b), or imputed (c) and a weakly informative prior is used. (d), (e), and (f) show the corresponding uncertainty around the CDF (in the form of the 0.5 and 0.8 uncertain intervals) that result from (a), (b), and (c), respectively. The true parameter values and CDF are shown in red."
p_full_inf <- stan_fit_lt_r_imputed_inf %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5) +
  xlab(expression(beta)) +
  ylab(expression(eta)) +
  theme_minimal()
p_no_lt_inf <- stan_fit_no_lt_inf  %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5) +
  xlab(expression(beta)) +
  ylab(expression(eta)) +
  theme_minimal()
p_imp_lt_inf <- stan_fit_unknown_lt_rc_inf %>%
  mcmc_scatter(pars = c("beta", "eta")) +
  geom_point(x = beta, y = eta, colour = "red") +
  xlim(0, 5) +
  ylim(0, 5) +
  xlab(expression(beta)) +
  ylab(expression(eta)) +
  theme_minimal()

p_cdf_full_inf <- PlotPostCDF(stan_fit_lt_r_imputed_inf)
p_cdf_no_lt_inf <- PlotPostCDF(stan_fit_no_lt_inf)
p_cdf_imp_lt_inf <- PlotPostCDF(stan_fit_unknown_lt_rc_inf)

p_joint_posts_inf <- plot_grid(
  p_full_inf, p_no_lt_inf, p_imp_lt_inf,
  p_cdf_full_inf, p_cdf_no_lt_inf, p_cdf_imp_lt_inf,
  nrow = 2,
  ncol = 3,
  labels = c(
    "(a)", "(b)", "(c)",
    "(d)", "(e)", "(f)"
  ),
  label_fontfamily = "Times",
  label_face = "plain"
)
p_joint_posts_inf
```

```{r}
#| label: save-fig-join-posts-inf
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "joint-posts-inf.pdf"),
  height = 5,
  width = 10
)
p_joint_posts_inf 
dev.off()
```

```{r}
#| label: fig-prior-post-comparison
#| fig-cap: "Comparison of the marginal prior and posterior for F_t1 and F_t2 when left-truncated lifetimes are fully observed (a), discarded (b), or imputed (c) to show how both the elicited distributions have been updated in the posterior."
p1 <- stan_fit_lt_r_imputed_inf %>%
  as_draws_rvars() %>%
  gather_rvars(t1CDF, t2CDF) %>%
  mutate(
    prior = c(
      rvar(rnorm(500000, 0.80, 0.1)),
      rvar(rnorm(500000, 0.95, 0.05))
    )
  ) %>%
  ggplot() +
  stat_halfeye(aes(xdist = .value, y = .variable)) +
  stat_slab(aes(xdist = prior, y = .variable), fill = NA, color = "#e41a1c") +
  scale_y_discrete(
    labels = c(
      expression(t[1]),
      expression(t[2])
    )
  ) +
  ylab("") +
  xlab(expression(F(t[i]))) +
  xlim(0, 1) +
  theme_minimal()
p2 <- stan_fit_no_lt_inf %>%
  as_draws_rvars() %>%
  gather_rvars(t1CDF, t2CDF) %>%
  mutate(
    prior = c(
      rvar(rnorm(500000, 0.80, 0.1)),
      rvar(rnorm(500000, 0.95, 0.05))
    )
  ) %>%
  ggplot() +
  stat_halfeye(aes(xdist = .value, y = .variable)) +
  stat_slab(aes(xdist = prior, y = .variable), fill = NA, color = "#e41a1c") +
  scale_y_discrete(
    labels = c(
      expression(t[1]),
      expression(t[2])
    )
  ) +
  ylab("") +
  xlab(expression(F(t[i]))) +
  xlim(0, 1) +
  theme_minimal()
p3 <- stan_fit_unknown_lt_rc_inf %>%
  as_draws_rvars() %>%
  gather_rvars(t1CDF, t2CDF) %>%
  mutate(
    prior = c(
      rvar(rnorm(500000, 0.80, 0.1)),
      rvar(rnorm(500000, 0.95, 0.05))
    )
  ) %>%
  ggplot() +
  stat_halfeye(aes(xdist = .value, y = .variable)) +
  stat_slab(aes(xdist = prior, y = .variable), fill = NA, color = "#e41a1c") +
  scale_y_discrete(
    labels = c(
      expression(t[1]),
      expression(t[2])
    )
  ) +
  ylab("") +
  xlab(expression(F(t[i]))) +
  xlim(0, 1) +
  theme_minimal()

plot_grid(
  p1, p2, p3,
  nrow = 1, ncol = 3,
  labels = c(
    "(a)", "(b)", "(c)"
  ),
  label_fontfamily = "Times",
  label_face = "plain"
)
```

```{r}
#| label: save-fig-prior-post-comparison
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "prior-post-comp.pdf"),
  height = 5,
  width = 10
)
plot_grid(
  p1, p2, p3,
  nrow = 1, ncol = 3,
  labels = c(
    "(a)", "(b)", "(c)"
  ),
  label_fontfamily = "Times",
  label_face = "plain"
)
dev.off()
```

# Sim study

The simulation study was run on a vertual machine on the [Nimbus](https://pawsey.org.au/systems/nimbus-cloud-service/) cloud server with _____ provided by [Pawsey](https://pawsey.org.au/). The Rscripts for the simulation studies for $\beta = 0.8$, $1.1$, and $2$ are [left-trunc-sim-study-0.8.R](./left-trunc-sim-study-0.8.R), [left-trunc-sim-study-1.1.R](./left-trunc-sim-study-1.1.R), and [left-trunc-sim-study-2.R](./left-trunc-sim-study-2.R), respectively. A detailed description of the simulation study is provided in Sec. 2.5 of the Thesis.

::: panel-tabset
#### $\beta = 1.1$
```{r}
#| label: load-sim-results
experiment_results_df <- readRDS("LT_experiment_results_df.rds")
```

```{r}
#| label: fig-sim-result-factor-plots
#| fig-cap: "..."
GetFactorValue <- function(x) as.numeric(as.character(x))
ModelLabeller <- function(name_string) {
  if (stringr::str_detect(name_string, "stan_fit_imp_lt")) {
    model_name <- "imputed"
  } else if (stringr::str_detect(name_string, "stan_fit_full")) {
    model_name <- "known"
  } else {
    model_name <- "discarded"
  }
  return(model_name)
}
PriorLabeller <- function(name_string) {
  if (stringr::str_detect(name_string, "weak")) {
    prior_name <- "weak"
  } else {
    prior_name <- "strong"
  }
  return(prior_name)
}

experiment_results_df %>%
  mutate(
    model_name = lapply(
      experiment_results_df$model,
      ModelLabeller
    ) %>% unlist(),
    prior_name = lapply(
      experiment_results_df$model,
      PriorLabeller
    ) %>% unlist()
  ) %>%
  ggplot(
    aes(
      x = p_value_beta, y = p_value_eta,
      size = E_log_score, colour = model_name,
      shape = prior_name
    )
  ) +
  geom_point(alpha = 0.5) +
  xlim(0, 1) +
  ylim(0, 1) +
  facet_grid(rows = vars(t_start), cols = vars(N, t_window)) +
  xlab(expression(P[beta])) +
  ylab(expression(P[eta])) +
  theme(
    panel.background = element_rect(
      fill = "white", colour = "white"
    ),
    panel.grid.major = element_line(
      size = 0.5,
      colour = alpha("lightgrey", 0.5)
    ),
    panel.grid.minor =  element_line(
      size = 0.25,
      colour = alpha("lightgrey", 0.5)
    ),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank()
  )
```

```{r}
#| label: fig-sim-result-factor-plots-means
#| fig-cap: "..."
p_sim_result_plot <- experiment_results_df %>%
  mutate(
    model = lapply(
      experiment_results_df$model,
      ModelLabeller
    ) %>% unlist(),
    prior = lapply(
      experiment_results_df$model,
      PriorLabeller
    ) %>% unlist()
  ) %>%
  filter(!is.infinite(E_log_score)) %>%
  group_by(
    N, t_start, t_window, model, prior
  ) %>%
  summarise(
    p_value_beta = mean(p_value_beta, na.rm = TRUE),
    p_value_eta = mean(p_value_eta, na.rm = TRUE),
    elppd = mean(E_log_score, na.rm = TRUE)
  ) %>%
  ggplot(
    aes(
      x = p_value_beta, y = p_value_eta,
      size = elppd, colour = model,
      shape = prior
    )
  ) +
  geom_point(alpha = 0.5) +
  xlim(0, 1) +
  ylim(0, 1) +
  facet_grid(rows = vars(N, t_start), cols = vars(t_window)) +
  xlab(expression(P[beta])) +
  ylab(expression(P[eta])) +
  theme(
    panel.background = element_rect(
      fill = "white", colour = "white"
    ),
    panel.grid.major = element_line(
      size = 0.5,
      colour = alpha("lightgrey", 0.5)
    ),
    panel.grid.minor =  element_line(
      size = 0.25,
      colour = alpha("lightgrey", 0.5)
    ),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank()
  )

p_sim_result_plot
```

```{r}
#| label: save-fig-sim-result-factor-plots-means
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "sim-results-pvalues.pdf"),
  height = 15,
  width = 10
)
p_sim_result_plot
dev.off()
```

```{r}
#| label: fig-sim-result-elppd-plots
#| fig-cap: "..."
experiment_results_df %>%
  mutate(
    model_name = lapply(
      experiment_results_df$model,
      ModelLabeller
    ) %>% unlist(),
    prior_name = lapply(
      experiment_results_df$model,
      PriorLabeller
    ) %>% unlist(),
    N = factor(N)
  ) %>%
  ggplot(
    aes(
      x = N, y = E_log_score,
      colour = model_name,
      shape = prior_name
    )
  ) +
  geom_jitter(
    alpha = 0.5,
    width = 0.25
  ) +
  facet_grid(rows = vars(t_start), cols = vars(t_window)) +
  theme(
    panel.background = element_rect(
      fill = "white", colour = "white"
    ),
    panel.grid.major = element_line(
      size = 0.5,
      colour = alpha("lightgrey", 0.5)
    ),
    panel.grid.minor =  element_line(
      size = 0.25,
      colour = alpha("lightgrey", 0.5)
    ),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank()
  )
```

```{r}
#| label: fig-sim-result-elppd-plots-means
#| fig-cap: "..."
p_sim_res_elppd <- experiment_results_df %>%
  mutate(
    model = lapply(
      experiment_results_df$model,
      ModelLabeller
    ) %>% unlist(),
    prior = lapply(
      experiment_results_df$model,
      PriorLabeller
    ) %>% unlist()
  ) %>%
  filter(!is.infinite(E_log_score)) %>%
  group_by(
    N, t_start, t_window, model, prior
  ) %>%
  summarise(
    p_value_beta = mean(p_value_beta, na.rm = TRUE),
    p_value_eta = mean(p_value_eta, na.rm = TRUE),
    elppd = mean(E_log_score, na.rm = TRUE)
  ) %>%
  ggplot(
    aes(
      x = N, y = elppd,
      colour = model,
      shape = prior
    )
  ) +
  geom_jitter(
    alpha = 0.5,
    width = 0.25
  ) +
  facet_grid(rows = vars(t_window), cols = vars(t_start))+
  theme(
    panel.background = element_rect(
      fill = "white", colour = "white"
    ),
    panel.grid.major = element_line(
      size = 0.5,
      colour = alpha("lightgrey", 0.5)
    ),
    panel.grid.minor =  element_line(
      size = 0.25,
      colour = alpha("lightgrey", 0.5)
    ),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank()
  )

p_sim_res_elppd
```

```{r}
#| label: save-fig-sim-result-elppd-plots-means
#| echo: false
#| output: false
pdf(
  file.path(fig_path, "sim-results-elppd.pdf"),
  height = 8.,
  width = 8
)
p_sim_res_elppd
dev.off()
```

#### $\beta = 0.8$

#### $\beta = 2.0$

:::

# Appendix - A

In this appendix I demonstrate how the joint posterior of $\beta$ and $\eta$ derived using the method originaly proposed in @kaminskiy2005 depends on the analysts choise of $t_1$ or $t_2$ when regenerating the posterior draws after updataing the distribution of the CDF at time $t_3$.
@fig-kamiskiy-original-demo (a) shows the joint posterior when the distributions at $t_3$ and $t_2$ are used to generate the posterior draws and (b) shows the joint posterior when the distributions at $t_3$ and $t_1$ are used. The two joint distributions in @fig-kamiskiy-original-demo are very clearly diferent.

```{r}
#| label: fig-kamiskiy-original-demo
#| fig-cal: "The joint posterior of $\beta$ and $\eta$ when (a) the distributions at $t_3$ and $t_2$ are used to generate the posterior draws and (b) shows the joint posterior when the distributions at $t_3$ and $t_1$ are used."
CalcBetaParams <- function(m, v) {
  a = ((m^2 - m^3) / v) - m
  b = (a / m) - a
  return(list(shape1 = a, shape2 = b))
}
rbetaMeanSd <- function(N, m, v) {
  pars <- CalcBetaParams(m, v)
  random_samp <- rbeta(N, pars$shape1, pars$shape2)
  return(random_samp)
}
# Define elicitation and observation times
t_1 <- qweibull(0.3, beta, eta)
t_2 <- qweibull(0.7, beta, eta)
t_3 <- qweibull(0.2, beta, eta)

# Generate samples from the joint prior
prior <- data.frame(
  F1 = rbetaMeanSd(10000, 0.3, 0.05),
  F2 = rbetaMeanSd(10000, 0.7, 0.02)
) %>%
  filter(F2 > F1) %>%
  mutate(
    beta = (fn(F2) - fn(F1)) / log(t_2 / t_1),
    eta = exp(log(t_1) - (fn(F1) / beta)),
    F3_prior = pweibull(t_3, beta, eta)
  )
# Calculate coresponding values of beta distribution at t_3
F3_prior_params <- CalcBetaParams(
  m = mean(prior$F3_prior),
  v = var(prior$F3_prior)
)
# Generate some binomial data from true data generateing process
binom_data <- rbinom(
  n = 1,
  size = 10,
  prob = 0.2
)
# Calculate posterior of P at t_3
shape1_post <- F3_prior_params$shape1 + binom_data
shape2_post <- F3_prior_params$shape2 + (10 - binom_data)
# Generate samples from joint post using t_2
post1 <- data.frame(
  F3_post = rbeta(10000, shape1_post, shape2_post),
  F2 = rbetaMeanSd(10000, 0.7, 0.02)
) %>%
  filter(F2 > F3_post) %>%
  mutate(
    beta = (fn(F2) - fn(F3_post)) / log(t_2 / t_3),
    eta = exp(log(t_3) - (fn(F3_post) / beta))
  )
p1 <- post1 %>%
  ggplot(aes(x = beta, y = eta)) +
  geom_point() +
  ylim(0, 10) +
  xlim(0, 10) +
  xlab(expression(P[beta])) +
  ylab(expression(P[eta])) +
  theme_minimal()
# Generate samples from joint post using t_1
post2 <- data.frame(
  F3_post = rbeta(10000, shape1_post, shape2_post),
  F1 = rbetaMeanSd(10000, 0.3, 0.05)
) %>%
  filter(F1 > F3_post) %>%
  mutate(
    beta = (fn(F1) - fn(F3_post)) / log(t_1 / t_3),
    eta = exp(log(t_3) - (fn(F3_post) / beta))
  )
p2 <- post2 %>%
  ggplot(aes(x = beta, y = eta)) +
  geom_point() +
  ylim(0, 10) +
  xlim(0, 10) +
  theme_minimal() +
  xlab(expression(P[beta])) +
  ylab(expression(P[eta])) +
  theme_minimal()
# Generate samples f
# Compare the two posteriors
cowplot::plot_grid(
  p1, p2,
  nrow = 1, ncol = 2,
  labels = c(
    "(a)", "(b)"
  ),
  label_fontfamily = "Times",
  label_face = "plain"
)
```
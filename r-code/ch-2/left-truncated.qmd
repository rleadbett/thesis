---
title: "Demonstration of bias"
author:
  - name: Ryan Leadbetter
    orcid: 0000-0002-1942-3121
    email: ryan.leadbetter@curtin.edu.au
    affiliation: 
      - name: Centre for Transforming Maintenance Through Data Science  
        url: https://www.maintenance.org.au/dashboard.action
      - Curtin University
date: "`r Sys.Date()`"
format: 
  html:
    embed-resources: true
    fig-width: 7
    fig-height: 5
    toc: true
    toc-depth: 3
    toc-location: left
    toc-expand: true
execute:
  warning: false
  message: false
  cache: true
---

```{r}
library(rstan)
library(dplyr)
library(ggplot2)
library(bayesplot)
library(posterior)
library(tidybayes)
library(cowplot)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
```

I have rethought the issue and done some more reading. The articles by [Guo 1993](https://doi.org/10.2307/271011) and [Hong, Meeker, & McCalley 2009](https://projecteuclid.org/journals/annals-of-applied-statistics/volume-3/issue-2/Prediction-of-remaining-life-of-power-transformers-based-on-left/10.1214/00-AOAS231.full) discuss cases of left truncation in datasets that are relatable to the idler failure time data. The argument is that any "unit" that has a history of exposure before we begin observing failures, i.e. idlers that were already installed at the time we started recording data, are left truncated. The justification for this is that if we imagine a "cohort" of idlers being istalled at a time before we have begun our observational experiment, then the idlers which make it into our experiment are conditional on them surviving long enough. Thus, if we do not account for the left truncation of the lifetime distributions of idlers already installed at the beginning of the observation, then we are biasing the results towards longer lifetimes. In the case of Hong, Meeker, & McCalley 2009, the left truncation times are knonw. They show how one can model data which is both left truncated and right censored using an example of power transformer failure data. The likelihood they construct is

$$
L(\theta) = \prod^N_{i = 1} f(t_i)^{\delta_T \delta_C} \left(1 - F(t_i)\right)^{\delta_T (1 - \delta_C)}\left(\frac{f(t_i)}{1 - F(t^L_i)}\right)^{(1 - \delta_T) \delta_C}\left(\frac{1 - F(t_i)}{1 - F(t^L_i)}\right)^{(1 - \delta_T) (1 - \delta_C)}.
$$

Where $f(.)$ and $F(.)$ are the PDF and CDF of the lifetime distribution respectively, $\delta_T$ and $\delta_L$ are indicator variables of if lifetime $t_i$ is left truncated, $\delta_T = 0$, or right censored $\delta_C = 0$, and $t^L_i$ is the left truncation time of lifetime $t_i$ if it is left truncated.

Guo 1993 points out that if a portion of the data is left truncated the two options are either to throw all of the left truncated lifetimes away, in which case we lose valuable information about loger lifetimes, or to accound for it in the same way as Hong, Meeker, & McCalley 2009 have. But Gou goes on to discuss the issues that arise when the start of the left truncation lifetime is unknown, i.e. if we don't know the left truncated untis history of exposure before it entered the experiment. If this is the case, there are very few options available and best option is seemingly to throw away the left truncated observations.

Unfortunately this is the case for the idler lifetime data, there are some idlers that were already installed when we began observing them and we do not know what time they were intalled. This is a messy mix of interval censoring and left tuncation. This may appear similar to the paper by ([Mitra, & Narayanaswamy 2021](https://doi.org/10.1080/03610918.2019.1577968)), howerver, they look at the case where lifetimes are left truncated at the begining of the lifetime with known truncation time and interval censored at the end of the lifetime. The idlers are left truncated with unknown truncation times and censored at the begining of the lifetime. This may seem confusing at the moment but hopefuly I can break this down later.

# Imputing vs integrating out censored lifetimes

Most of the published approaches, including Guo 1993, Hong, Meeker, & McCalley 2009, Mitra, & Narayanaswamy 2021 use a form of the likelihood where, the censored lifetimes are "integrated out" using the fact that for a right censored lifetime, the likelihood of that lifetime being right censored is equal to the likelihood that they lifetime is greater than the censoring time, which can be writen as the $P(T > t^C|\theta) = 1 - F(t^C|\theta)$, where $t^c$ is the censoring time (i.e. the time from installation of the unit to when it was censored). For an interval censored observation this would be the probability that the true lifetime falls between the interval, $P(t^{up} > T > t^{low}|\theta) = F(t^{up}|\theta) - F(t^{low}|\theta)$, where $t^{up}$ and $t^{low}$ are the upper and lower bounds of the interval censored lifetime. Note that right censoring is a special case of interval censoring where $t^{up} = \infty$ since $F(\infty) = 1$.

Alternatively, if we are using the Bayesian framework, we have another option. We can impute the censored lifetime data by treating the censored observations as parameters and asigning them a prior ([Stan User's Guide](https://mc-stan.org/docs/stan-users-guide/truncation-censoring.html#censored-data)). For example, if we are using the Weibull distribution with shape $\beta$ and scale $\eta$, we can assign the prior

$$
t^{C}_i \sim \hbox{Weibull}^{t^{up}}_{t^{low}}(\beta, \eta)
$$

to the partialy observed censored lifetimes, $t^{C}_i$, and impute their values. In the above prior, $\hbox{Weibull}^{t^{up}}_{t^{low}}$ is a Weibull distribution that is truncated between the upper and lower bounds of the censored lifetime. Once again note that this includes both right and interval censoring since for right censoring $t^{up} = \infty$.

Using this approach, we can also impute the truncation time of idlers that were installed before the observation period so long as we observe them failing during the experiment. Howerver, I will discuss this a bit later. First I'll construct stan models for both models and fit them to some simulated data where the left truncation times are known (which is essentialy what Hong, Meeker, & McCalley 2009 do).

# Left truncation and right censoring models

Set true parameters

```{r}
# parameters of the weibull distribution
beta <- 1.1
eta <- 1

# number of units
N <- 200
t_start <- 5
t_window <- 1
t_end <- t_start + t_window
```

Simulate some data

```{r}
SimData <- function(
  beta,
  eta,
  n_units,
  t_start,
  t_end
){
  # Calculate how many lifetimes to sample
  weibull_05_quant <- qweibull(0.05, shape = beta, scale = eta)
  n_lifetimes_per_unit <- ceiling(t_end / weibull_05_quant) * 2

  # Create simulation data frame
  small_sim <- data.frame(
      # Define units
      unit = factor(
        rep(1:n_units, each = n_lifetimes_per_unit),
        1:n_units
      ),
      # Sample for Weibull distribution
      lifetime = rweibull(
        n_units * n_lifetimes_per_unit,
        shape = beta,
        scale = eta
      )
    ) %>% 
    group_by(unit) %>%
    # Calculate the failure times and install times
    mutate(
      failure_time = cumsum(lifetime),
      install_time = lag(failure_time),
      lifetime_id = 1:n()
    ) %>%
    ungroup() %>%
    # Replace NAs created by lag() with t = 0
    replace(is.na(.), 0) %>%
    # Discard any lifetimes that didn't fail or within the observation period
    filter(
      between(install_time, t_start, t_end) |
      between(failure_time, t_start, t_end) |
      ((install_time < t_start) & (failure_time > t_end))
    ) %>%
    # Create right and interval censoring indicator variables
    mutate(
      int_censored = !between(install_time, t_start, t_end),
      right_censored = !between(failure_time, t_start, t_end),
      install_time_obs = ifelse(int_censored, t_start, install_time),
      failure_time_obs = ifelse(right_censored, t_end, failure_time)
    )

  return(small_sim)
}

set.seed(549)
sim_df <- SimData(
  beta = beta,
  eta = eta,
  n_units = N,
  t_start = t_start,
  t_end = t_end
)

head(sim_df)
```

Prepare data for stan

```{r}
sim_df_obs <- sim_df %>%
  filter(!(right_censored | int_censored))
sim_df_rc <- sim_df %>%
  filter(right_censored & !int_censored)
sim_df_lt <- sim_df %>%
  filter(!right_censored & int_censored)
sim_df_lt_rc <- sim_df %>%
  filter(right_censored & int_censored)

stan_data_lt_observed <- list(
  N_obs = nrow(sim_df_obs),
  N_rc = nrow(sim_df_rc),
  N_lt = nrow(sim_df_lt),
  N_lt_rc = nrow(sim_df_lt_rc),
  y_obs = sim_df_obs$failure_time - sim_df_obs$install_time,
  y_rc = sim_df_rc$failure_time_obs - sim_df_rc$install_time,
  y_lt = sim_df_lt$failure_time - sim_df_lt$install_time,
  t_lt = sim_df_lt$install_time_obs - sim_df_lt$install_time,
  y_lt_rc = sim_df_lt_rc$failure_time_obs - sim_df_lt_rc$install_time,
  t_lt_rc = sim_df_lt_rc$install_time_obs - sim_df_lt_rc$install_time
)
```

Define and sample from stan model where censored data are integrated over.

```{r}
stan_model_lt_r_integrated <- stan_model(
  model_code = "
data {
int N_obs;
int N_rc;
int N_lt;
int N_lt_rc;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
vector<lower=0>[N_lt] y_lt;
vector<lower=0>[N_lt] t_lt;
vector<lower=0>[N_lt_rc] y_lt_rc;
vector<lower=0>[N_lt_rc] t_lt_rc;
}
parameters {
real<lower = 0> beta;
real<lower = 0> eta;
}
model{
// Data model
// fully observed lifetimes
target += weibull_lpdf(y_obs|beta, eta);
// right censored lifetimes
target += weibull_lccdf(y_rc|beta, eta);
// left truncated lifetimes
target += weibull_lpdf(y_lt|beta, eta) - weibull_lccdf(t_lt|beta, eta);
// left truncated and right censored lifetimes
target += weibull_lccdf(y_lt_rc|beta, eta) - weibull_lccdf(t_lt_rc|beta, eta);

// Prior model
eta ~ normal(1, 1);
beta ~ normal(1.1, 1);
}

"
)

stan_fit_lt_r_integrated <- sampling(
  stan_model_lt_r_integrated,
  stan_data_lt_observed,
  cores = 4,
  iter = 5000,
  warmup = 500,
  open_progress = FALSE,
  verbose = FALSE,
  show_messages = FALSE,
  refresh = FALSE
)

p1 <- mcmc_scatter(
  stan_fit_lt_r_integrated,
  pars = c("beta", "eta")
) +
geom_point(x = 1.1, y = 1, colour = "red") +
xlim(0, 3) +
ylim(0, 3)
```

Define and sample from stan model where censored data are imputed.

```{r}
stan_model_lt_r_imputed <- stan_model(
  model_code = "
data {
int N_obs;
int N_rc;
int N_lt;
int N_lt_rc;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
vector<lower=0>[N_lt] y_lt;
vector<lower=0>[N_lt] t_lt;
vector<lower=0>[N_lt_rc] y_lt_rc;
vector<lower=0>[N_lt_rc] t_lt_rc;
}
parameters {
real<lower = 0> beta;
real<lower = 0> eta;
vector<lower = y_rc>[N_rc] y_rc_hat;
vector<lower = y_lt_rc>[N_lt_rc] y_lt_rc_hat;
}
model{
// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}
// left truncated and right censored lifetimes
for (j in 1:N_lt_rc) {
  y_lt_rc_hat[j] ~ weibull(beta, eta) T[t_lt_rc[j], ]; 
}

// Prior model
eta ~ normal(1, 1);
beta ~ normal(1.1, 1);
}

"
)

stan_fit_lt_r_imputed <- sampling(
  stan_model_lt_r_imputed,
  stan_data_lt_observed,
  cores = 4,
  iter = 600,
  warmup = 200#,
  #open_progress = FALSE,
  #verbose = FALSE,
  #show_messages = FALSE,
  #refresh = FALSE
)

p2 <- mcmc_scatter(
  stan_fit_lt_r_imputed,
  pars = c("beta", "eta")
) +
geom_point(x = 1.1, y = 1, colour = "red") +
xlim(0, 3) +
ylim(0, 3)
```

Compare the two posteriors. They should be the same... almost

```{r}
#| column: page
#| fig-width: 12
#| fig-height: 12

cowplot::plot_grid(
  p1, p2,
  nrow = 1,
  labels = c(
    "integrated out", "imputed"
  ),
  label_size = 10
)
```

Now compare with a model where we throw out all of the truncated samples, as Guo 1993 suggests can be done (but not prefereable).

```{r}
#| column: page
#| fig-width: 12
#| fig-height: 12

stan_model_rc_integrated <- stan_model(
  model_code = "
data {
int N_obs;
int N_rc;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
}
parameters {
real<lower = 0> beta;
real<lower = 0> eta;
}
model{
// Data model
// fully observed lifetimes
target += weibull_lpdf(y_obs|beta, eta);
// right censored lifetimes
target += weibull_lccdf(y_rc|beta, eta);

// Prior model
eta ~ normal(1, 1);
beta ~ normal(1.1, 1);
}

"
)

stan_data_lt_dropped <- list(
  N_obs = nrow(sim_df_obs),
  N_rc = nrow(sim_df_rc),
  y_obs = sim_df_obs$failure_time - sim_df_obs$install_time,
  y_rc = sim_df_rc$failure_time_obs - sim_df_rc$install_time
)

stan_fit_rc_integrated <- sampling(
  stan_model_rc_integrated,
  stan_data_lt_dropped,
  cores = 4,
  iter = 5000,
  warmup = 500,
  open_progress = FALSE,
  verbose = FALSE,
  show_messages = FALSE,
  refresh = FALSE
)

p3 <- mcmc_scatter(
  stan_fit_rc_integrated,
  pars = c("beta", "eta")
) +
geom_point(x = 1.1, y = 1, colour = "red") +
xlim(0, 3) +
ylim(0, 3)

cowplot::plot_grid(
  p1, p2, p3,
  nrow = 1,
  labels = c(
    "observed truncated integrated out",
    "observed truncated imputed",
    "no truncated"
  ),
  label_size = 10
)
```

We can see that while the true parameter values are still captured in the posterior when we discard the left truncated samples, but including these samples in the model drasticaly reduces uncertainty in the posterior. Below I visualise the posterior distribution of the CDF under the different models.

```{r}
#| column: page
#| fig-width: 12
#| fig-height: 12

grid <- seq(0, 5, 0.01)

p_cdf_lt_rc_integrated <- stan_fit_lt_r_integrated %>%
  as_draws_df() %>%
  select(beta, eta) %>%
  split(., seq(nrow(.))) %>%
  lapply(
    function(draw) {
      df_CDF <- data.frame(
        q = grid,
        p = pweibull(grid, draw$beta, draw$eta)
      )
      return(df_CDF)
    }
  ) %>%
  bind_rows() %>%
  ggplot() +
  stat_lineribbon(
    aes(x = q, y = p),
    .width = c(0.5, 0.8, 0.98)
  ) +
  scale_fill_brewer() +
  geom_function(
    fun = pweibull,
    args = list(shape = beta, scale = eta),
    colour = "red"
  ) +
  theme_minimal()

p_cdf_lt_rc_imputed <- stan_fit_lt_r_imputed %>%
  as_draws_df() %>%
  select(beta, eta) %>%
  split(., seq(nrow(.))) %>%
  lapply(
    function(draw) {
      df_CDF <- data.frame(
        q = grid,
        p = pweibull(grid, draw$beta, draw$eta)
      )
      return(df_CDF)
    }
  ) %>%
  bind_rows() %>%
  ggplot() +
  stat_lineribbon(
    aes(x = q, y = p),
    .width = c(0.5, 0.8, 0.98)
  ) +
  scale_fill_brewer() +
  geom_function(
    fun = pweibull,
    args = list(shape = beta, scale = eta),
    colour = "red"
  ) +
  theme_minimal()

p_cdf_rc_integrated <- stan_fit_rc_integrated %>%
  as_draws_df() %>%
  select(beta, eta) %>%
  split(., seq(nrow(.))) %>%
  lapply(
    function(draw) {
      df_CDF <- data.frame(
        q = grid,
        p = pweibull(grid, draw$beta, draw$eta)
      )
      return(df_CDF)
    }
  ) %>%
  bind_rows() %>%
  ggplot() +
  stat_lineribbon(
    aes(x = q, y = p),
    .width = c(0.5, 0.8, 0.98)
  ) +
  scale_fill_brewer() +
  geom_function(
    fun = pweibull,
    args = list(shape = beta, scale = eta),
    colour = "red"
  ) +
  theme_minimal()

cowplot::plot_grid(
  p_cdf_lt_rc_integrated,
  p_cdf_lt_rc_imputed,
  p_cdf_rc_integrated,
  nrow = 1,
    labels = c(
    "observed truncated integrated out",
    "observed truncated imputed",
    "no truncated"
  ),
  label_size = 10
)
```

The most uncertain part of the CDF is the upper tail, since this is where the data are least informative. The Kaminskiy method can help here.

# Unknown truncation times

In section 2 of Guo 1993, he discusses the issue of left truncation time when the start of exposure for a unit is unknown. In a way, the left truncated data in these cases is interval censored, sinse we know that the lifetime is longer than the period of time that it was observed for. But the left truncation times are now also random variables. This case is dificult to deal with when using the method where we integrate out the censored lifetimes. However, when using the imputation method in a Bayesian framework we can still handel this kind of data (to the best of my knowledge there is no publications that do this).

Consider first the case where a lifetime is left truncated with unknown install time and an observed failure time (i.e. not right truncated at the end of the lifetime). In this case we can treat the lifetime as censored, since we know that it must have been installed before the begining of observation at $t = 2$ but after $t = 0$ (if we didn't know that there was a $t = 0$ we could still treat the lifetime as right censored) and impute the partialy observed lifetime. Using the imputed value of the lifetime, we can then calculate the left truncation time

$$
t^{C}_i \sim \hbox{Weibull}^{t^{up}}_{t^{low}}(\beta, \eta) 
$$

$$
t^L = t^{C}_i - t^{low}
$$

When the lifetime is both left truncated at the begining of the lifetime with unknown start time and right censored at the end of the lifetime, we cannot calculate the left truncation time. For the moment, let us neglect the lifetimes which are both left truncated and right censored. The stan code for this model is

```{r}
stan_model_unknown_lt <- stan_model(
  model_code = "
data {
int N_obs;
int N_rc;
int N_lt;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
vector<lower=0>[N_lt] y_lt;
real<lower=0> t_start;
}
transformed data{
vector<lower=0>[N_lt] y_lt_upper;

y_lt_upper = y_lt + t_start;
}
parameters {
real<lower= 0> beta;
real<lower= 0> eta;
vector<lower=y_rc>[N_rc] y_rc_hat;
vector<lower=y_lt, upper=y_lt_upper>[N_lt] y_lt_hat;
}
transformed parameters{
vector<lower=0>[N_lt] t_lt;

t_lt = y_lt_hat - y_lt;
}
model{
// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt_hat[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}

// Prior model
eta ~ normal(1, 1);
beta ~ normal(1.1, 1);
}

"
)

stan_data_lt_unobserved <- list(
  N_obs = nrow(sim_df_obs),
  N_rc = nrow(sim_df_rc),
  N_lt = nrow(sim_df_lt),
  y_obs = sim_df_obs$failure_time - sim_df_obs$install_time,
  y_rc = sim_df_rc$failure_time_obs - sim_df_rc$install_time_obs,
  y_lt = sim_df_lt$failure_time_obs - sim_df_lt$install_time_obs,
  t_start = t_start
)

stan_fit_unknown_lt <- sampling(
  stan_model_unknown_lt,
  stan_data_lt_unobserved,
  chains = 4,
  iter = 1000,
  warmup = 500,
  open_progress = FALSE,
  verbose = FALSE,
  show_messages = FALSE,
  refresh = FALSE
)

p4 <- mcmc_scatter(
  stan_fit_unknown_lt,
  pars = c("beta", "eta")
) +
geom_point(x = 1.1, y = 1, colour = "red") +
xlim(0, 3) +
ylim(0, 3)
```

Fitting this model to the data seams to work but because we have thrown away some of the data, we've introduces some bias.

```{r}
#| column: page
#| fig-width: 12
#| fig-height: 12

plot_grid(
  p2, p3, p4,
  nrow = 1,
  labels = c(
    "observed truncated", "no truncated", "imputed truncated"
  ),
  label_size = 10
)
```

One way we can account for the left-truncated and right censored lifetimes is by assigning a prior to $t^L$ if we know an upper and lower bounds for it, like we do for the idler problem. This should then add in the extra uncertainty into our model.

$$
t^{C}_i \sim \hbox{Weibull}^{\infty}_{t^{low}}(\beta, \eta) 
$$

$$
t^L \sim \hbox{Uniform}(0, min((t^{C}_i - t^{low}), t_{start}))
$$

Where $t_{start}$ is the time that we started the experiment, in this case $t_{start} = 2$. I implement this in stan below.

```{r}
stan_model_unknown_lt_rc <- stan_model(
  model_code = "
data {
int N_obs;                             # N fully observed lives
int N_rc;                              # N right censored only lives
int N_lt;                              # N left truncated only lives
int N_lt_rc;                           # N right cens and left trunc lives
array[N_obs] real<lower=0> y_obs;      # Fully observed lifetimes
array[N_rc] real<lower=0> y_rc;        # Right censored lifetimes
array[N_lt] real<lower=0> y_lt;        # Left trunc lifetimes
array[N_lt_rc] real<lower=0> y_lt_rc;  # right cens and left trunc lifetimes
real<lower=0> t_start;                 # start of the observation window
}
transformed data{
array[N_lt] real<lower=0> y_lt_upper;  # The upper bound of the left trunc lives

for (m in 1:N_lt){
  y_lt_upper[m] = y_lt[m] + t_start;   # Upper bound = lower bound + start of observation
}

}
parameters {
real<lower= 0> beta;     # weibull shape
real<lower= 0> eta;      # weibull scale
array[N_rc] real<lower=y_rc> y_rc_hat;   # imputed right censored values
array[N_lt] real<lower=y_lt, upper=y_lt_upper> y_lt_hat;  # imputed left trunc values
array[N_lt_rc] real<lower=y_lt_rc> y_lt_rc_hat;   # imputed left trunc and right cens values
array[N_lt_rc] real<lower=0, upper=1> t_lt_rc_st; # imputed left truncation times for left trunc and right cens values (standardised)
}
transformed parameters{
array[N_lt] real t_lt;  # imputed left trunc times for left trunc values
array[N_lt_rc] real<lower=0, upper=t_start> t_lt_rc_upper;
array[N_lt_rc] real<lower=0, upper=t_lt_rc_upper> t_lt_rc;  # imputed left trunc times for left trunc and right cens values

for (i in 1:N_lt) {
  t_lt[i] = y_lt_hat[i] - y_lt[i];
}

for (k in 1:N_lt_rc){
  if ((y_lt_rc_hat[k] - y_lt_rc[k]) < t_start)
    t_lt_rc_upper[k] = y_lt_rc_hat[k] - y_lt_rc[k];
  else
    t_lt_rc_upper[k] = t_start;

  t_lt_rc[k] = t_lt_rc_st[k] * t_lt_rc_upper[k];
}
}
model{
// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt_hat[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}
// left truncated and right censored lifetimes
for (j in 1:N_lt_rc) {
  y_lt_rc_hat[j] ~ weibull(beta, eta) T[t_lt_rc[j], ]; 
}

// Prior model
eta ~ normal(1, 1);
beta ~ normal(1.1, 1);
t_lt_rc_st ~ uniform(0, 1);
}

"
)

```

Sample from posterior.

```{r}
stan_data_lt_unobserved_rc <- list(
  N_obs = nrow(sim_df_obs),
  N_rc = nrow(sim_df_rc),
  N_lt = nrow(sim_df_lt),
  N_lt_rc = nrow(sim_df_lt_rc),
  y_obs = sim_df_obs$failure_time - sim_df_obs$install_time,
  y_rc = sim_df_rc$failure_time_obs - sim_df_rc$install_time_obs,
  y_lt = sim_df_lt$failure_time_obs - sim_df_lt$install_time_obs,
  y_lt_rc = sim_df_lt_rc$failure_time_obs - sim_df_lt_rc$install_time_obs,
  t_start = t_start
)

stan_fit_unknown_lt_rc <- sampling(
  stan_model_unknown_lt_rc,
  stan_data_lt_unobserved_rc,
  chains = 4,
  iter = 800,
  warmup = 400#,
  #control = list(adapt_delta = 0.99, max_treedepth = 14)#,
  #open_progress = FALSE,
  #verbose = FALSE,
  #show_messages = FALSE,
  #refresh = FALSE
)

p5 <- mcmc_scatter(
  stan_fit_unknown_lt_rc,
  pars = c("beta", "eta")
) +
geom_point(x = 1.1, y = 1, colour = "red") +
xlim(0, 3) +
ylim(0, 3)
```

The result is a reduction in the bias compared to the case where we've thrown out the left truncated and right censored lifetimes.

```{r}
#| column: page
#| fig-width: 12
#| fig-height: 12

plot_grid(
  p2, p3, p4, p5,
  nrow = 2,
  labels = c(
    "observed truncated", "no truncated",
    "imputed truncated", "imputed truncated and censored"
  ),
  label_size = 10
)
```

The CDFs for these two new models compared to the case where we know the truncation times and when we discard all the truncated lifetimes.

```{r}
#| column: page
#| fig-width: 12
#| fig-height: 12

p_cdf_unknown_lt <- stan_fit_unknown_lt %>%
  as_draws_df() %>%
  select(beta, eta) %>%
  split(., seq(nrow(.))) %>%
  lapply(
    function(draw) {
      df_CDF <- data.frame(
        q = grid,
        p = pweibull(grid, draw$beta, draw$eta)
      )
      return(df_CDF)
    }
  ) %>%
  bind_rows() %>%
  ggplot() +
  stat_lineribbon(
    aes(x = q, y = p),
    .width = c(0.5, 0.8, 0.98)
  ) +
  scale_fill_brewer() +
  geom_function(
    fun = pweibull,
    args = list(shape = beta, scale = eta),
    colour = "red"
  ) +
  theme_minimal()

p_cdf_unknown_lt_rc <- stan_fit_unknown_lt_rc %>%
  as_draws_df() %>%
  select(beta, eta) %>%
  split(., seq(nrow(.))) %>%
  lapply(
    function(draw) {
      df_CDF <- data.frame(
        q = grid,
        p = pweibull(grid, draw$beta, draw$eta)
      )
      return(df_CDF)
    }
  ) %>%
  bind_rows() %>%
  ggplot() +
  stat_lineribbon(
    aes(x = q, y = p),
    .width = c(0.5, 0.8, 0.98)
  ) +
  scale_fill_brewer() +
  geom_function(
    fun = pweibull,
    args = list(shape = beta, scale = eta),
    colour = "red"
  ) +
  theme_minimal()

cowplot::plot_grid(
  p_cdf_lt_rc_imputed,
  p_cdf_rc_integrated,
  p_cdf_unknown_lt,
  p_cdf_unknown_lt_rc,
  labels = c(
    "observed truncated", "no truncated",
    "imputed truncated", "imputed truncated and censored"
  ),
  label_size = 10
)
```

It is most important that we estimate the lower tail of the lifetime distribution, since these will be the unexpected failures that will risk damaging the system and will blow out the cost of a fixed time replacment strategy.

```{r}
#| column: page
#| fig-width: 12
#| fig-height: 12

grid <- seq(0, 1, 0.01)

p_cdf_unknown_lt <- stan_fit_unknown_lt %>%
  as_draws_df() %>%
  select(beta, eta) %>%
  split(., seq(nrow(.))) %>%
  lapply(
    function(draw) {
      df_CDF <- data.frame(
        q = grid,
        p = pweibull(grid, draw$beta, draw$eta)
      )
      return(df_CDF)
    }
  ) %>%
  bind_rows() %>%
  ggplot() +
  stat_lineribbon(
    aes(x = q, y = p),
    .width = c(0.5, 0.8, 0.98)
  ) +
  scale_fill_brewer() +
  geom_function(
    fun = pweibull,
    args = list(shape = beta, scale = eta),
    colour = "red"
  ) +
  theme_minimal()

p_cdf_unknown_lt_rc <- stan_fit_unknown_lt_rc %>%
  as_draws_df() %>%
  select(beta, eta) %>%
  split(., seq(nrow(.))) %>%
  lapply(
    function(draw) {
      df_CDF <- data.frame(
        q = grid,
        p = pweibull(grid, draw$beta, draw$eta)
      )
      return(df_CDF)
    }
  ) %>%
  bind_rows() %>%
  ggplot() +
  stat_lineribbon(
    aes(x = q, y = p),
    .width = c(0.5, 0.8, 0.98)
  ) +
  scale_fill_brewer() +
  geom_function(
    fun = pweibull,
    args = list(shape = beta, scale = eta),
    colour = "red"
  ) +
  theme_minimal()

cowplot::plot_grid(
  p_cdf_lt_rc_imputed,
  p_cdf_rc_integrated,
  p_cdf_unknown_lt,
  p_cdf_unknown_lt_rc,
  labels = c(
    "observed truncated", "no truncated",
    "imputed truncated", "imputed truncated and censored"
  ),
  label_size = 10
)
```

# Joint prior


```{r}
stan_model_lt_r_imputed_joint <- stan_model(
  model_code = "
functions {
// function to simplify the calculation of eta and beta
real fn(real tCDF) {
  return log(-log1m(tCDF));
}
}
data {
int N_obs;
int N_rc;
int N_lt;
int N_lt_rc;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
vector<lower=0>[N_lt] y_lt;
vector<lower=0>[N_lt] t_lt;
vector<lower=0>[N_lt_rc] y_lt_rc;
vector<lower=0>[N_lt_rc] t_lt_rc;
// Define the prior
real t_1;
real t_2;
real t1_mean;
real t1_var;
real t2_mean;
real t2_var;
}
parameters {
real<lower = 0, upper = 1> t1CDF;
real<lower = t1CDF, upper = 1> t2CDF;
vector<lower = y_rc>[N_rc] y_rc_hat;
vector<lower = y_lt_rc>[N_lt_rc] y_lt_rc_hat;
}
transformed parameters {
real<lower = 0> beta;
real<lower = 0> eta;

// calculate Weibull paramaters based on the
// draws from the CDF at t1 and t2.
beta = (fn(t2CDF) - fn(t1CDF)) / log(t_2 / t_1);
eta = exp(log(t_1) - (fn(t1CDF) / beta));
}
model{
// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}
// left truncated and right censored lifetimes
for (j in 1:N_lt_rc) {
  y_lt_rc_hat[j] ~ weibull(beta, eta) T[t_lt_rc[j], ]; 
}

// Prior model
t1CDF ~ normal(t1_mean, t1_var);
t2CDF ~ normal(t2_mean, t2_var);
}

"
)

stan_fit_lt_r_imputed_joint <- sampling(
  stan_model_lt_r_imputed_joint,
  c(
    stan_data_lt_observed,
    t_1 = qweibull(0.5, beta, eta),
    t_2 = qweibull(0.98, beta, eta),
    t1_mean = 0.5,
    t1_var = 0.1,
    t2_mean = 0.98,
    t2_var = 0.05
  ),
  cores = 4,
  iter = 5000,
  warmup = 500,
  open_progress = FALSE,
  verbose = FALSE,
  show_messages = FALSE,
  refresh = FALSE
)

p2.2 <- mcmc_scatter(
  stan_fit_lt_r_imputed_joint,
  pars = c("beta", "eta")
) +
geom_point(x = 1.1, y = 1, colour = "red") +
xlim(0, 3) +
ylim(0, 3)

p_cdf_lt_r_imputed_joint <- stan_fit_lt_r_imputed_joint %>%
  as_draws_df() %>%
  select(beta, eta) %>%
  split(., seq(nrow(.))) %>%
  lapply(
    function(draw) {
      df_CDF <- data.frame(
        q = grid,
        p = pweibull(grid, draw$beta, draw$eta)
      )
      return(df_CDF)
    }
  ) %>%
  bind_rows() %>%
  ggplot() +
  stat_lineribbon(
    aes(x = q, y = p),
    .width = c(0.5, 0.8, 0.98)
  ) +
  scale_fill_brewer() +
  geom_function(
    fun = pweibull,
    args = list(shape = beta, scale = eta),
    colour = "red"
  ) +
  theme_minimal()

plot_grid(
  p2, p2.2,
  p_cdf_lt_rc_integrated, p_cdf_lt_r_imputed_joint,
  nrow = 2
)
```


```{r}
stan_model_rc_integrated_joint <- stan_model(
  model_code = "
functions {
// function to simplify the calculation of eta and beta
real fn(real tCDF) {
  return log(-log1m(tCDF));
}
}
data {
int N_obs;
int N_rc;
vector<lower=0>[N_obs] y_obs;
vector<lower=0>[N_rc] y_rc;
// Define the prior
real t_1;
real t_2;
real t1_mean;
real t1_var;
real t2_mean;
real t2_var;
}
parameters {
real<lower = 0, upper = 1> t1CDF;
real<lower = t1CDF, upper = 1> t2CDF;
}
transformed parameters {
real<lower = 0> beta;
real<lower = 0> eta;

// calculate Weibull paramaters based on the
// draws from the CDF at t1 and t2.
beta = (fn(t2CDF) - fn(t1CDF)) / log(t_2 / t_1);
eta = exp(log(t_1) - (fn(t1CDF) / beta));
}
model{
// Data model
// fully observed lifetimes
target += weibull_lpdf(y_obs|beta, eta);
// right censored lifetimes
target += weibull_lccdf(y_rc|beta, eta);

// Prior model
t1CDF ~ normal(t1_mean, t1_var);
t2CDF ~ normal(t2_mean, t2_var);
}

"
)

stan_fit_rc_integrated_joint <- sampling(
  stan_model_rc_integrated_joint,
  c(
    stan_data_lt_dropped,
    t_1 = qweibull(0.5, beta, eta),
    t_2 = qweibull(0.98, beta, eta),
    t1_mean = 0.5,
    t1_var = 0.1,
    t2_mean = 0.98,
    t2_var = 0.05
  ),
  cores = 4,
  iter = 5000,
  warmup = 500,
  open_progress = FALSE,
  verbose = FALSE,
  show_messages = FALSE,
  refresh = FALSE
)

p3.2 <- mcmc_scatter(
  stan_fit_rc_integrated_joint,
  pars = c("beta", "eta")
) +
geom_point(x = 1.1, y = 1, colour = "red") +
xlim(0, 3) +
ylim(0, 3)

p_cdf_rc_integrated_joint <- stan_fit_rc_integrated_joint %>%
  as_draws_df() %>%
  select(beta, eta) %>%
  split(., seq(nrow(.))) %>%
  lapply(
    function(draw) {
      df_CDF <- data.frame(
        q = grid,
        p = pweibull(grid, draw$beta, draw$eta)
      )
      return(df_CDF)
    }
  ) %>%
  bind_rows() %>%
  ggplot() +
  stat_lineribbon(
    aes(x = q, y = p),
    .width = c(0.5, 0.8, 0.98)
  ) +
  scale_fill_brewer() +
  geom_function(
    fun = pweibull,
    args = list(shape = beta, scale = eta),
    colour = "red"
  ) +
  theme_minimal()

plot_grid(
  p2, p2.2, p3, p3.2,
  p_cdf_lt_rc_integrated, p_cdf_lt_r_imputed_joint,
  p_cdf_rc_integrated, p_cdf_rc_integrated_joint,
  nrow = 2
)
```



```{r}
stan_model_unknown_lt_rc_joint <- stan_model(
  model_code = "
functions {
// function to simplify the calculation of eta and beta
real fn(real tCDF) {
  return log(-log1m(tCDF));
}
}
data {
int N_obs;                             # N fully observed lives
int N_rc;                              # N right censored only lives
int N_lt;                              # N left truncated only lives
int N_lt_rc;                           # N right cens and left trunc lives
array[N_obs] real<lower=0> y_obs;      # Fully observed lifetimes
array[N_rc] real<lower=0> y_rc;        # Right censored lifetimes
array[N_lt] real<lower=0> y_lt;        # Left trunc lifetimes
array[N_lt_rc] real<lower=0> y_lt_rc;  # right cens and left trunc lifetimes
real<lower=0> t_start;                 # start of the observation window
// Define the prior
real t_1;
real t_2;
real t1_mean;
real t1_var;
real t2_mean;
real t2_var;
}
transformed data{
array[N_lt] real<lower=0> y_lt_upper;  # The upper bound of the left trunc lives

for (m in 1:N_lt){
  y_lt_upper[m] = y_lt[m] + t_start;   # Upper bound = lower bound + start of observation
}

}
parameters {
real<lower = 0, upper = 1> t1CDF;
real<lower = t1CDF, upper = 1> t2CDF;
array[N_rc] real<lower=y_rc> y_rc_hat;   # imputed right censored values
array[N_lt] real<lower=y_lt, upper=y_lt_upper> y_lt_hat;  # imputed left trunc values
array[N_lt_rc] real<lower=y_lt_rc> y_lt_rc_hat;   # imputed left trunc and right cens values
array[N_lt_rc] real<lower=0, upper=1> t_lt_rc_st; # imputed left truncation times for left trunc and right cens values (standardised)
}
transformed parameters{
real<lower = 0> beta;
real<lower = 0> eta;
array[N_lt] real t_lt;  # imputed left trunc times for left trunc values
array[N_lt_rc] real<lower=0, upper=t_start> t_lt_rc_upper;
array[N_lt_rc] real<lower=0, upper=t_lt_rc_upper> t_lt_rc;  # imputed left trunc times for left trunc and right cens values

// calculate Weibull paramaters based on the
// draws from the CDF at t1 and t2.
beta = (fn(t2CDF) - fn(t1CDF)) / log(t_2 / t_1);
eta = exp(log(t_1) - (fn(t1CDF) / beta));

for (i in 1:N_lt) {
  t_lt[i] = y_lt_hat[i] - y_lt[i];
}

for (k in 1:N_lt_rc){
  if ((y_lt_rc_hat[k] - y_lt_rc[k]) < t_start)
    t_lt_rc_upper[k] = y_lt_rc_hat[k] - y_lt_rc[k];
  else
    t_lt_rc_upper[k] = t_start;

  t_lt_rc[k] = t_lt_rc_st[k] * t_lt_rc_upper[k];
}
}
model{
// Data model
// fully observed lifetimes
y_obs ~ weibull(beta, eta);
// right censored lifetimes
y_rc_hat ~ weibull(beta, eta);
// left truncated lifetimes
for (i in 1:N_lt) {
  y_lt_hat[i] ~ weibull(beta, eta) T[t_lt[i], ]; 
}
// left truncated and right censored lifetimes
for (j in 1:N_lt_rc) {
  y_lt_rc_hat[j] ~ weibull(beta, eta) T[t_lt_rc[j], ]; 
}

// Prior model
t1CDF ~ normal(t1_mean, t1_var);
t2CDF ~ normal(t2_mean, t2_var);
t_lt_rc_st ~ uniform(0, 1);
}

"
)
```


```{r}
stan_fit_unknown_lt_rc_joint <- sampling(
  stan_model_unknown_lt_rc_joint,
  c(
    stan_data_lt_unobserved_rc,
    t_1 = qweibull(0.5, beta, eta),
    t_2 = qweibull(0.98, beta, eta),
    t1_mean = 0.5,
    t1_var = 0.1,
    t2_mean = 0.98,
    t2_var = 0.05
  ),
  chains = 4,
  iter = 800,
  warmup = 400#,
  #open_progress = FALSE,
  #verbose = FALSE,
  #show_messages = FALSE,
  #refresh = FALSE
)

p5.2 <- mcmc_scatter(
  stan_fit_unknown_lt_rc_joint,
  pars = c("beta", "eta")
) +
geom_point(x = 1.1, y = 1, colour = "red") +
xlim(0, 3) +
ylim(0, 3)

plot_grid(p2, p5, p5.2, nrow = 1)
```



```{r}
N_units <- 10000
t_window <- 4
junk <- data.frame(
  unit = as.character(rep(1:N_units, 1000)),
  y = rweibull(N_units * 1000, beta, eta)
) %>%
group_by(unit) %>%
mutate(
  ft = cumsum(y),
  it = lag(ft),
  it = ifelse(is.na(it), 0, it)
)

TruncTimeDist <- function(t_start) {
  df_truncated <- junk %>%
    filter(
      ((t_start > it) & (t_start < ft) & ((t_start + t_window) < ft))
    ) %>%
    mutate(
      trunc_time = t_start - it,
      trunc_limit = y - t_window,
      trunc_limit = ifelse(trunc_limit > t_start, t_start, trunc_limit),
      trunct_std = trunc_time / trunc_limit
    )
  p <- ggplot() +
    geom_density(
      data = data.frame(
        ittr = as.character(1:100),
        x = runif(nrow(df_truncated) * 100)
      ),
      aes(x = x, group = ittr),
      bounds = c(0, 1),
      colour = "grey",
      alpha = 0.4
    ) +
    geom_density(
      data = df_truncated,
      aes(x = trunct_std), bounds = c(0, 1)
    ) +
    geom_rug(
      data = df_truncated,
      aes(x = trunct_std)
    ) +
    xlim(0, 1) +
    theme_minimal()
  return(p)
}

p_list <- lapply(
  seq(0.2, 10, length.out = (4 * 4)),
  TruncTimeDist
)

plot_grid(
  plotlist = p_list,
  labels = stringr::str_c(
    "t_start = ",
    round(seq(0.2, 10, length.out = (4 * 4)), 2)
  ),
  label_size = 10,
  label_x = 0.2
)
```